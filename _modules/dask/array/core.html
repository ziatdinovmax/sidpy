

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dask.array.core &mdash; sidpy 0.0.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> sidpy
          

          
          </a>

          
            
            
              <div class="version">
                0.0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">SIDpy</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../external_guides.html">Tutorials on Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Guidelines for Contribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../matlab.html">Upgrading from Matlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact us</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/sidpy.html">sidpy</a></li>
</ul>
<p class="caption"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/00_basic_usage/index.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/01_parallel_computing/index.html">Parallel computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/02_visualization/index.html">Visualization</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sidpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>dask.array.core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for dask.array.core</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">zip_longest</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span><span class="p">,</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">getitem</span><span class="p">,</span> <span class="n">mul</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>

<span class="kn">from</span> <span class="nn">tlz</span> <span class="kn">import</span> <span class="n">partition</span><span class="p">,</span> <span class="n">concat</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">accumulate</span><span class="p">,</span> <span class="n">frequencies</span>
<span class="kn">from</span> <span class="nn">tlz.curried</span> <span class="kn">import</span> <span class="n">pluck</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">chunk</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">compute</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DaskMethodsMixin</span><span class="p">,</span>
    <span class="n">tokenize</span><span class="p">,</span>
    <span class="n">dont_optimize</span><span class="p">,</span>
    <span class="n">compute_as_if_collection</span><span class="p">,</span>
    <span class="n">persist</span><span class="p">,</span>
    <span class="n">is_dask_collection</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..blockwise</span> <span class="kn">import</span> <span class="n">broadcast_dimensions</span>
<span class="kn">from</span> <span class="nn">..context</span> <span class="kn">import</span> <span class="n">globalmethod</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ndeepmap</span><span class="p">,</span>
    <span class="n">ignoring</span><span class="p">,</span>
    <span class="n">concrete</span><span class="p">,</span>
    <span class="n">derived_from</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">IndexCallable</span><span class="p">,</span>
    <span class="n">funcname</span><span class="p">,</span>
    <span class="n">SerializableLock</span><span class="p">,</span>
    <span class="n">Dispatch</span><span class="p">,</span>
    <span class="n">factors</span><span class="p">,</span>
    <span class="n">parse_bytes</span><span class="p">,</span>
    <span class="n">has_keyword</span><span class="p">,</span>
    <span class="n">M</span><span class="p">,</span>
    <span class="n">ndimlist</span><span class="p">,</span>
    <span class="n">format_bytes</span><span class="p">,</span>
    <span class="n">typename</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">quote</span>
<span class="kn">from</span> <span class="nn">..delayed</span> <span class="kn">import</span> <span class="n">delayed</span><span class="p">,</span> <span class="n">Delayed</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">threaded</span><span class="p">,</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">..sizeof</span> <span class="kn">import</span> <span class="n">sizeof</span>
<span class="kn">from</span> <span class="nn">..highlevelgraph</span> <span class="kn">import</span> <span class="n">HighLevelGraph</span>
<span class="kn">from</span> <span class="nn">.numpy_compat</span> <span class="kn">import</span> <span class="n">_Recurser</span><span class="p">,</span> <span class="n">_make_sliced_dtype</span>
<span class="kn">from</span> <span class="nn">.slicing</span> <span class="kn">import</span> <span class="n">slice_array</span><span class="p">,</span> <span class="n">replace_ellipsis</span><span class="p">,</span> <span class="n">cached_cumsum</span>
<span class="kn">from</span> <span class="nn">.blockwise</span> <span class="kn">import</span> <span class="n">blockwise</span>
<span class="kn">from</span> <span class="nn">.chunk_types</span> <span class="kn">import</span> <span class="n">is_valid_array_chunk</span><span class="p">,</span> <span class="n">is_valid_chunk_type</span>


<span class="n">config</span><span class="o">.</span><span class="n">update_defaults</span><span class="p">({</span><span class="s2">&quot;array&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;chunk-size&quot;</span><span class="p">:</span> <span class="s2">&quot;128MiB&quot;</span><span class="p">,</span> <span class="s2">&quot;rechunk-threshold&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}})</span>


<span class="n">concatenate_lookup</span> <span class="o">=</span> <span class="n">Dispatch</span><span class="p">(</span><span class="s2">&quot;concatenate&quot;</span><span class="p">)</span>
<span class="n">tensordot_lookup</span> <span class="o">=</span> <span class="n">Dispatch</span><span class="p">(</span><span class="s2">&quot;tensordot&quot;</span><span class="p">)</span>
<span class="n">einsum_lookup</span> <span class="o">=</span> <span class="n">Dispatch</span><span class="p">(</span><span class="s2">&quot;einsum&quot;</span><span class="p">)</span>
<span class="n">concatenate_lookup</span><span class="o">.</span><span class="n">register</span><span class="p">((</span><span class="nb">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">)</span>
<span class="n">tensordot_lookup</span><span class="o">.</span><span class="n">register</span><span class="p">((</span><span class="nb">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">)</span>
<span class="n">einsum_lookup</span><span class="o">.</span><span class="n">register</span><span class="p">((</span><span class="nb">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">)</span>

<span class="n">unknown_chunk_message</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;A possible solution: &quot;</span>
    <span class="s2">&quot;https://docs.dask.org/en/latest/array-chunks.html#unknown-chunks</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;Summary: to compute chunks sizes, use</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;   x.compute_chunk_sizes()  # for Dask Array `x`</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="s2">&quot;   ddf.to_dask_array(lengths=True)  # for Dask DataFrame `ddf`&quot;</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">PerformanceWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A warning given when bad chunking may cause poor performance &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">b3</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">getter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="n">asarray</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)[</span><span class="n">b3</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">lock</span><span class="p">:</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">asarray</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lock</span><span class="p">:</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">c</span>


<span class="k">def</span> <span class="nf">getter_nofancy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A simple wrapper around ``getter``.</span>

<span class="sd">    Used to indicate to the optimization passes that the backend doesn&#39;t</span>
<span class="sd">    support fancy indexing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">getter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="n">asarray</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">getter_inline</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A getter function that optimizations feel comfortable inlining</span>

<span class="sd">    Slicing operations with this function may be inlined into a graph, such as</span>
<span class="sd">    in the following rewrite</span>

<span class="sd">    **Before**</span>

<span class="sd">    &gt;&gt;&gt; a = x[:10]  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; b = a + 1  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; c = a * 2  # doctest: +SKIP</span>

<span class="sd">    **After**</span>

<span class="sd">    &gt;&gt;&gt; b = x[:10] + 1  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; c = x[:10] * 2  # doctest: +SKIP</span>

<span class="sd">    This inlining can be relevant to operations when running off of disk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">getter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="n">asarray</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">.optimization</span> <span class="kn">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">fuse_slice</span>


<span class="c1"># __array_function__ dict for mapping aliases and mismatching names</span>
<span class="n">_HANDLED_FUNCTIONS</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">implements</span><span class="p">(</span><span class="o">*</span><span class="n">numpy_functions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Register an __array_function__ implementation for dask.array.Array</span>

<span class="sd">    Register that a function implements the API of a NumPy function (or several</span>
<span class="sd">    NumPy functions in case of aliases) which is handled with</span>
<span class="sd">    ``__array_function__``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    \\*numpy_functions : callables</span>
<span class="sd">        One or more NumPy functions that are handled by ``__array_function__``</span>
<span class="sd">        and will be mapped by `implements` to a `dask.array` function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">dask_func</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">numpy_function</span> <span class="ow">in</span> <span class="n">numpy_functions</span><span class="p">:</span>
            <span class="n">_HANDLED_FUNCTIONS</span><span class="p">[</span><span class="n">numpy_function</span><span class="p">]</span> <span class="o">=</span> <span class="n">dask_func</span>

        <span class="k">return</span> <span class="n">dask_func</span>

    <span class="k">return</span> <span class="n">decorator</span>


<span class="k">def</span> <span class="nf">_should_delegate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Check whether Dask should delegate to the other.</span>
<span class="sd">    This implementation follows NEP-13:</span>
<span class="sd">    https://numpy.org/neps/nep-0013-ufunc-overrides.html#behavior-in-combination-with-python-s-binary-operations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;__array_ufunc__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">__array_ufunc__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="p">(</span>
        <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;__array_ufunc__&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_valid_array_chunk</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">__array_ufunc__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Array</span><span class="o">.</span><span class="n">__array_ufunc__</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">check_if_handled_given_other</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if method is handled by Dask given type of other</span>

<span class="sd">    Ensures proper deferral to upcast types in dunder operations without</span>
<span class="sd">    assuming unknown types are automatically downcast types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_should_delegate</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">slices_from_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Translate chunks tuple to a set of slices in product order</span>

<span class="sd">    &gt;&gt;&gt; slices_from_chunks(((2, 2), (3, 3, 3)))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">     [(slice(0, 2, None), slice(0, 3, None)),</span>
<span class="sd">      (slice(0, 2, None), slice(3, 6, None)),</span>
<span class="sd">      (slice(0, 2, None), slice(6, 9, None)),</span>
<span class="sd">      (slice(2, 4, None), slice(0, 3, None)),</span>
<span class="sd">      (slice(2, 4, None), slice(3, 6, None)),</span>
<span class="sd">      (slice(2, 4, None), slice(6, 9, None))]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cumdims</span> <span class="o">=</span> <span class="p">[</span><span class="n">cached_cumsum</span><span class="p">(</span><span class="n">bds</span><span class="p">,</span> <span class="n">initial_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">bds</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">shapes</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">starts</span><span class="p">,</span> <span class="n">shapes</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cumdims</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">slices</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">getem</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">,</span>
    <span class="n">chunks</span><span class="p">,</span>
    <span class="n">getitem</span><span class="o">=</span><span class="n">getter</span><span class="p">,</span>
    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">out_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">asarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dask getting various chunks from an array-like</span>

<span class="sd">    &gt;&gt;&gt; getem(&#39;X&#39;, chunks=(2, 3), shape=(4, 6))  # doctest: +SKIP</span>
<span class="sd">    {(&#39;X&#39;, 0, 0): (getter, &#39;X&#39;, (slice(0, 2), slice(0, 3))),</span>
<span class="sd">     (&#39;X&#39;, 1, 0): (getter, &#39;X&#39;, (slice(2, 4), slice(0, 3))),</span>
<span class="sd">     (&#39;X&#39;, 1, 1): (getter, &#39;X&#39;, (slice(2, 4), slice(3, 6))),</span>
<span class="sd">     (&#39;X&#39;, 0, 1): (getter, &#39;X&#39;, (slice(0, 2), slice(3, 6)))}</span>

<span class="sd">    &gt;&gt;&gt; getem(&#39;X&#39;, chunks=((2, 2), (3, 3)))  # doctest: +SKIP</span>
<span class="sd">    {(&#39;X&#39;, 0, 0): (getter, &#39;X&#39;, (slice(0, 2), slice(0, 3))),</span>
<span class="sd">     (&#39;X&#39;, 1, 0): (getter, &#39;X&#39;, (slice(2, 4), slice(0, 3))),</span>
<span class="sd">     (&#39;X&#39;, 1, 1): (getter, &#39;X&#39;, (slice(2, 4), slice(3, 6))),</span>
<span class="sd">     (&#39;X&#39;, 0, 1): (getter, &#39;X&#39;, (slice(0, 2), slice(3, 6)))}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_name</span> <span class="o">=</span> <span class="n">out_name</span> <span class="ow">or</span> <span class="n">arr</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">normalize_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">product</span><span class="p">([</span><span class="n">out_name</span><span class="p">],</span> <span class="o">*</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bds</span><span class="p">))</span> <span class="k">for</span> <span class="n">bds</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">))</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">slices_from_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">has_keyword</span><span class="p">(</span><span class="n">getitem</span><span class="p">,</span> <span class="s2">&quot;asarray&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">has_keyword</span><span class="p">(</span><span class="n">getitem</span><span class="p">,</span> <span class="s2">&quot;lock&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">asarray</span> <span class="ow">or</span> <span class="n">lock</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[(</span><span class="n">getitem</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">lock</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Common case, drop extra parameters</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[(</span><span class="n">getitem</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">]</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">dotmany</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">leftfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rightfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dot product of many aligned chunks</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2], [1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([[10, 20], [10, 20]])</span>
<span class="sd">    &gt;&gt;&gt; dotmany([x, x, x], [y, y, y])</span>
<span class="sd">    array([[ 90, 180],</span>
<span class="sd">           [ 90, 180]])</span>

<span class="sd">    Optionally pass in functions to apply to the left and right chunks</span>

<span class="sd">    &gt;&gt;&gt; dotmany([x, x, x], [y, y, y], rightfunc=np.transpose)</span>
<span class="sd">    array([[150, 150],</span>
<span class="sd">           [150, 150]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">leftfunc</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">leftfunc</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rightfunc</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">rightfunc</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_concatenate2</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;Recursively Concatenate nested lists of arrays along axes</span>

<span class="sd">    Each entry in axes corresponds to each level of the nested list.  The</span>
<span class="sd">    length of axes should correspond to the level of nesting of arrays.</span>
<span class="sd">    If axes is an empty list or tuple, return arrays, or arrays[0] if</span>
<span class="sd">    arrays is a list.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; _concatenate2([x, x], axes=[0])</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [1, 2],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    &gt;&gt;&gt; _concatenate2([x, x], axes=[1])</span>
<span class="sd">    array([[1, 2, 1, 2],</span>
<span class="sd">           [3, 4, 3, 4]])</span>

<span class="sd">    &gt;&gt;&gt; _concatenate2([[x, x], [x, x]], axes=[0, 1])</span>
<span class="sd">    array([[1, 2, 1, 2],</span>
<span class="sd">           [3, 4, 3, 4],</span>
<span class="sd">           [1, 2, 1, 2],</span>
<span class="sd">           [3, 4, 3, 4]])</span>

<span class="sd">    Supports Iterators</span>
<span class="sd">    &gt;&gt;&gt; _concatenate2(iter([x, x]), axes=[1])</span>
<span class="sd">    array([[1, 2, 1, 2],</span>
<span class="sd">           [3, 4, 3, 4]])</span>

<span class="sd">    Special Case</span>
<span class="sd">    &gt;&gt;&gt; _concatenate2([x, x], axes=())</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="o">==</span> <span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arrays</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">):</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">arrays</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">_concatenate2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
    <span class="n">concatenate</span> <span class="o">=</span> <span class="n">concatenate_lookup</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span>
        <span class="nb">type</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;__array_priority__&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">apply_infer_dtype</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">suggest_dtype</span><span class="o">=</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="n">nout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tries to infer output dtype of ``func`` for a small set of input arguments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func: Callable</span>
<span class="sd">        Function for which output dtype is to be determined</span>

<span class="sd">    args: List of array like</span>
<span class="sd">        Arguments to the function, which would usually be used. Only attributes</span>
<span class="sd">        ``ndim`` and ``dtype`` are used.</span>

<span class="sd">    kwargs: dict</span>
<span class="sd">        Additional ``kwargs`` to the ``func``</span>

<span class="sd">    funcname: String</span>
<span class="sd">        Name of calling function to improve potential error messages</span>

<span class="sd">    suggest_dtype: None/False or String</span>
<span class="sd">        If not ``None`` adds suggestion to potential error message to specify a dtype</span>
<span class="sd">        via the specified kwarg. Defaults to ``&#39;dtype&#39;``.</span>

<span class="sd">    nout: None or Int</span>
<span class="sd">        ``None`` if function returns single output, integer if many.</span>
<span class="sd">        Deafults to ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : dtype or List of dtype</span>
<span class="sd">        One or many dtypes (depending on ``nout``)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span>
    <span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_traceback</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_tb</span><span class="p">(</span><span class="n">exc_traceback</span><span class="p">))</span>
        <span class="n">suggest</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;Please specify the dtype explicitly using the &quot;</span>
                <span class="s2">&quot;`</span><span class="si">{dtype}</span><span class="s2">` kwarg.</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">suggest_dtype</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">suggest_dtype</span>
            <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;`dtype` inference failed in `</span><span class="si">{0}</span><span class="s2">`.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Original error is below:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;------------------------</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="si">{2}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Traceback:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;---------</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="si">{3}</span><span class="s2">&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="n">suggest</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">tb</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">nout</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">o</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">normalize_arg</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize user provided arguments to blockwise or map_blocks</span>

<span class="sd">    We do a few things:</span>

<span class="sd">    1.  If they are string literals that might collide with blockwise_token then we</span>
<span class="sd">        quote them</span>
<span class="sd">    2.  IF they are large (as defined by sizeof) then we put them into the</span>
<span class="sd">        graph on their own by using dask.delayed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_dask_collection</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;_\d+&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">delayed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">delayed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e6</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">delayed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_pass_extra_kwargs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper for :func:`map_blocks` to pass `block_info` or `block_id`.</span>

<span class="sd">    For each element of `keys`, a corresponding element of args is changed</span>
<span class="sd">    to a keyword argument with that key, before all arguments re passed on</span>
<span class="sd">    to `func`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="p">:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">map_blocks</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">token</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">chunks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">drop_axis</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">new_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Map a function across all blocks of a dask array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        Function to apply to every block in the array.</span>
<span class="sd">    args : dask arrays or other objects</span>
<span class="sd">    dtype : np.dtype, optional</span>
<span class="sd">        The ``dtype`` of the output array. It is recommended to provide this.</span>
<span class="sd">        If not provided, will be inferred by applying the function to a small</span>
<span class="sd">        set of fake data.</span>
<span class="sd">    chunks : tuple, optional</span>
<span class="sd">        Chunk shape of resulting blocks if the function does not preserve</span>
<span class="sd">        shape. If not provided, the resulting array is assumed to have the same</span>
<span class="sd">        block structure as the first input array.</span>
<span class="sd">    drop_axis : number or iterable, optional</span>
<span class="sd">        Dimensions lost by the function.</span>
<span class="sd">    new_axis : number or iterable, optional</span>
<span class="sd">        New dimensions created by the function. Note that these are applied</span>
<span class="sd">        after ``drop_axis`` (if present).</span>
<span class="sd">    token : string, optional</span>
<span class="sd">        The key prefix to use for the output array. If not provided, will be</span>
<span class="sd">        determined from the function name.</span>
<span class="sd">    name : string, optional</span>
<span class="sd">        The key name to use for the output array. Note that this fully</span>
<span class="sd">        specifies the output key name, and must be unique. If not provided,</span>
<span class="sd">        will be determined by a hash of the arguments.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Other keyword arguments to pass to function. Values must be constants</span>
<span class="sd">        (not dask.arrays)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dask.array.blockwise : Generalized operation with control over block alignment.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; x = da.arange(6, chunks=3)</span>

<span class="sd">    &gt;&gt;&gt; x.map_blocks(lambda x: x * 2).compute()</span>
<span class="sd">    array([ 0,  2,  4,  6,  8, 10])</span>

<span class="sd">    The ``da.map_blocks`` function can also accept multiple arrays.</span>

<span class="sd">    &gt;&gt;&gt; d = da.arange(5, chunks=2)</span>
<span class="sd">    &gt;&gt;&gt; e = da.arange(5, chunks=2)</span>

<span class="sd">    &gt;&gt;&gt; f = map_blocks(lambda a, b: a + b**2, d, e)</span>
<span class="sd">    &gt;&gt;&gt; f.compute()</span>
<span class="sd">    array([ 0,  2,  6, 12, 20])</span>

<span class="sd">    If the function changes shape of the blocks then you must provide chunks</span>
<span class="sd">    explicitly.</span>

<span class="sd">    &gt;&gt;&gt; y = x.map_blocks(lambda x: x[::2], chunks=((2, 2),))</span>

<span class="sd">    You have a bit of freedom in specifying chunks.  If all of the output chunk</span>
<span class="sd">    sizes are the same, you can provide just that chunk size as a single tuple.</span>

<span class="sd">    &gt;&gt;&gt; a = da.arange(18, chunks=(6,))</span>
<span class="sd">    &gt;&gt;&gt; b = a.map_blocks(lambda x: x[:3], chunks=(3,))</span>

<span class="sd">    If the function changes the dimension of the blocks you must specify the</span>
<span class="sd">    created or destroyed dimensions.</span>

<span class="sd">    &gt;&gt;&gt; b = a.map_blocks(lambda x: x[None, :, None], chunks=(1, 6, 1),</span>
<span class="sd">    ...                  new_axis=[0, 2])</span>

<span class="sd">    If ``chunks`` is specified but ``new_axis`` is not, then it is inferred to</span>
<span class="sd">    add the necessary number of axes on the left.</span>

<span class="sd">    Map_blocks aligns blocks by block positions without regard to shape. In the</span>
<span class="sd">    following example we have two arrays with the same number of blocks but</span>
<span class="sd">    with different shape and chunk sizes.</span>

<span class="sd">    &gt;&gt;&gt; x = da.arange(1000, chunks=(100,))</span>
<span class="sd">    &gt;&gt;&gt; y = da.arange(100, chunks=(10,))</span>

<span class="sd">    The relevant attribute to match is numblocks.</span>

<span class="sd">    &gt;&gt;&gt; x.numblocks</span>
<span class="sd">    (10,)</span>
<span class="sd">    &gt;&gt;&gt; y.numblocks</span>
<span class="sd">    (10,)</span>

<span class="sd">    If these match (up to broadcasting rules) then we can map arbitrary</span>
<span class="sd">    functions across blocks</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b):</span>
<span class="sd">    ...     return np.array([a.max(), b.max()])</span>

<span class="sd">    &gt;&gt;&gt; da.map_blocks(func, x, y, chunks=(2,), dtype=&#39;i8&#39;)</span>
<span class="sd">    dask.array&lt;func, shape=(20,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray&gt;</span>

<span class="sd">    &gt;&gt;&gt; _.compute()</span>
<span class="sd">    array([ 99,   9, 199,  19, 299,  29, 399,  39, 499,  49, 599,  59, 699,</span>
<span class="sd">            69, 799,  79, 899,  89, 999,  99])</span>

<span class="sd">    Your block function get information about where it is in the array by</span>
<span class="sd">    accepting a special ``block_info`` keyword argument.</span>

<span class="sd">    &gt;&gt;&gt; def func(block, block_info=None):</span>
<span class="sd">    ...     pass</span>

<span class="sd">    This will receive the following information:</span>

<span class="sd">    &gt;&gt;&gt; block_info  # doctest: +SKIP</span>
<span class="sd">    {0: {&#39;shape&#39;: (1000,),</span>
<span class="sd">         &#39;num-chunks&#39;: (10,),</span>
<span class="sd">         &#39;chunk-location&#39;: (4,),</span>
<span class="sd">         &#39;array-location&#39;: [(400, 500)]},</span>
<span class="sd">     None: {&#39;shape&#39;: (1000,),</span>
<span class="sd">            &#39;num-chunks&#39;: (10,),</span>
<span class="sd">            &#39;chunk-location&#39;: (4,),</span>
<span class="sd">            &#39;array-location&#39;: [(400, 500)],</span>
<span class="sd">            &#39;chunk-shape&#39;: (100,),</span>
<span class="sd">            &#39;dtype&#39;: dtype(&#39;float64&#39;)}}</span>

<span class="sd">    For each argument and keyword arguments that are dask arrays (the positions</span>
<span class="sd">    of which are the first index), you will receive the shape of the full</span>
<span class="sd">    array, the number of chunks of the full array in each dimension, the chunk</span>
<span class="sd">    location (for example the fourth chunk over in the first dimension), and</span>
<span class="sd">    the array location (for example the slice corresponding to ``40:50``). The</span>
<span class="sd">    same information is provided for the output, with the key ``None``, plus</span>
<span class="sd">    the shape and dtype that should be returned.</span>

<span class="sd">    These features can be combined to synthesize an array from scratch, for</span>
<span class="sd">    example:</span>

<span class="sd">    &gt;&gt;&gt; def func(block_info=None):</span>
<span class="sd">    ...     loc = block_info[None][&#39;array-location&#39;][0]</span>
<span class="sd">    ...     return np.arange(loc[0], loc[1])</span>

<span class="sd">    &gt;&gt;&gt; da.map_blocks(func, chunks=((4, 4),), dtype=np.float_)</span>
<span class="sd">    dask.array&lt;func, shape=(8,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray&gt;</span>

<span class="sd">    &gt;&gt;&gt; _.compute()</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7])</span>

<span class="sd">    You may specify the key name prefix of the resulting task in the graph with</span>
<span class="sd">    the optional ``token`` keyword argument.</span>

<span class="sd">    &gt;&gt;&gt; x.map_blocks(lambda x: x + 1, name=&#39;increment&#39;)  # doctest: +SKIP</span>
<span class="sd">    dask.array&lt;increment, shape=(100,), dtype=int64, chunksize=(10,), chunktype=numpy.ndarray&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;First argument must be callable function, not </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Usage:   da.map_blocks(function, x)</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;   or:   da.map_blocks(function, x, y, z)&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The token= keyword to map_blocks has been moved to name=&quot;</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">token</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="n">funcname</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="n">new_axes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drop_axis</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
        <span class="n">drop_axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">drop_axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_axis</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
        <span class="n">new_axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_axis</span><span class="p">]</span>  <span class="c1"># TODO: handle new_axis</span>

    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Array</span><span class="p">)]</span>

    <span class="n">argpairs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">arrs</span><span class="p">:</span>
        <span class="n">out_ind</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrs</span><span class="p">)))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_ind</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">original_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">apply_infer_dtype</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">original_kwargs</span><span class="p">,</span> <span class="s2">&quot;map_blocks&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">drop_axis</span><span class="p">:</span>
        <span class="n">out_ind</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out_ind</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">new_axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_ind</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
        <span class="n">new_axis</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_ind</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">new_axis</span><span class="p">:</span>
        <span class="c1"># new_axis = [x + len(drop_axis) for x in new_axis]</span>
        <span class="n">out_ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_ind</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">new_axis</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_ind</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">drop_axis</span><span class="p">)</span>
            <span class="n">out_ind</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_axes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_axes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">out_ind</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_ind</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">new_axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">out_ind</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;New_axis values do not fill in all dimensions&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_ind</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Provided chunks have </span><span class="si">{0}</span><span class="s2"> dims, expected </span><span class="si">{1}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;dims.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_ind</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">adjust_chunks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">out_ind</span><span class="p">,</span> <span class="n">chunks</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adjust_chunks</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span>
        <span class="n">out_ind</span><span class="p">,</span>
        <span class="o">*</span><span class="n">concat</span><span class="p">(</span><span class="n">argpairs</span><span class="p">),</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">new_axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">concatenate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">align_arrays</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">adjust_chunks</span><span class="o">=</span><span class="n">adjust_chunks</span><span class="p">,</span>
        <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">extra_argpairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">extra_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># If func has block_id as an argument, construct an array of block IDs and</span>
    <span class="c1"># prepare to inject it.</span>
    <span class="k">if</span> <span class="n">has_keyword</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;block_id&quot;</span><span class="p">):</span>
        <span class="n">block_id_name</span> <span class="o">=</span> <span class="s2">&quot;block-id-&quot;</span> <span class="o">+</span> <span class="n">out</span><span class="o">.</span><span class="n">name</span>
        <span class="n">block_id_dsk</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">block_id_name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">block_id</span><span class="p">:</span> <span class="n">block_id</span>
            <span class="k">for</span> <span class="n">block_id</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="n">block_id_array</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span>
            <span class="n">block_id_dsk</span><span class="p">,</span>
            <span class="n">block_id_name</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="nb">tuple</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">chunks</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">extra_argpairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">block_id_array</span><span class="p">,</span> <span class="n">out_ind</span><span class="p">))</span>
        <span class="n">extra_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;block_id&quot;</span><span class="p">)</span>

    <span class="c1"># If func has block_info as an argument, construct an array of block info</span>
    <span class="c1"># objects and prepare to inject it.</span>
    <span class="k">if</span> <span class="n">has_keyword</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;block_info&quot;</span><span class="p">):</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">num_chunks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">in_ind</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">argpairs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">in_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="n">drop_axis</span><span class="p">:</span>
                    <span class="c1"># We concatenate along dropped axes, so we need to treat them</span>
                    <span class="c1"># as if there is only a single chunk.</span>
                    <span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">(</span>
                            <span class="n">cached_cumsum</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">initial_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">out_ind</span>
                            <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">in_ind</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">num_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">cached_cumsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">initial_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">chunks</span>
                    <span class="p">]</span>
                    <span class="n">num_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">numblocks</span>
        <span class="n">out_starts</span> <span class="o">=</span> <span class="p">[</span><span class="n">cached_cumsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">initial_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">chunks</span><span class="p">]</span>

        <span class="n">block_info_name</span> <span class="o">=</span> <span class="s2">&quot;block-info-&quot;</span> <span class="o">+</span> <span class="n">out</span><span class="o">.</span><span class="n">name</span>
        <span class="n">block_info_dsk</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">block_id</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">chunks</span><span class="p">)):</span>
            <span class="c1"># Get position of chunk, indexed by axis labels</span>
            <span class="n">location</span> <span class="o">=</span> <span class="p">{</span><span class="n">out_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">loc</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">block_id</span><span class="p">)}</span>
            <span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Compute chunk key in the array, taking broadcasting into</span>
                <span class="c1"># account. We don&#39;t directly know which dimensions are</span>
                <span class="c1"># broadcast, but any dimension with only one chunk can be</span>
                <span class="c1"># treated as broadcast.</span>
                <span class="n">arr_k</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">location</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">num_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">argpairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="n">shape</span><span class="p">,</span>
                    <span class="s2">&quot;num-chunks&quot;</span><span class="p">:</span> <span class="n">num_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="s2">&quot;array-location&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="p">(</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ij</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ij</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr_k</span><span class="p">)</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;chunk-location&quot;</span><span class="p">:</span> <span class="n">arr_k</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="n">info</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="s2">&quot;num-chunks&quot;</span><span class="p">:</span> <span class="n">out</span><span class="o">.</span><span class="n">numblocks</span><span class="p">,</span>
                <span class="s2">&quot;array-location&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">out_starts</span><span class="p">[</span><span class="n">ij</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">out_starts</span><span class="p">[</span><span class="n">ij</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="s2">&quot;chunk-location&quot;</span><span class="p">:</span> <span class="n">block_id</span><span class="p">,</span>
                <span class="s2">&quot;chunk-shape&quot;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">ij</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">block_info_dsk</span><span class="p">[(</span><span class="n">block_info_name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">block_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span>

        <span class="n">block_info</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span>
            <span class="n">block_info_dsk</span><span class="p">,</span>
            <span class="n">block_info_name</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="nb">tuple</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">chunks</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">extra_argpairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">block_info</span><span class="p">,</span> <span class="n">out_ind</span><span class="p">))</span>
        <span class="n">extra_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;block_info&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">extra_argpairs</span><span class="p">:</span>
        <span class="c1"># Rewrite the Blockwise layer. It would be nice to find a way to</span>
        <span class="c1"># avoid doing it twice, but it&#39;s currently needed to determine</span>
        <span class="c1"># out.chunks from the first pass. Since it constructs a Blockwise</span>
        <span class="c1"># rather than an expanded graph, it shouldn&#39;t be too expensive.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span>
            <span class="n">_pass_extra_kwargs</span><span class="p">,</span>
            <span class="n">out_ind</span><span class="p">,</span>
            <span class="n">func</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">extra_names</span><span class="p">),</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="o">*</span><span class="n">concat</span><span class="p">(</span><span class="n">extra_argpairs</span><span class="p">),</span>
            <span class="o">*</span><span class="n">concat</span><span class="p">(</span><span class="n">argpairs</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">concatenate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">align_arrays</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">adjust_chunks</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">out_ind</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">chunks</span><span class="p">)),</span>
            <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">broadcast_chunks</span><span class="p">(</span><span class="o">*</span><span class="n">chunkss</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a chunks tuple that broadcasts many chunks tuples</span>

<span class="sd">    &gt;&gt;&gt; a = ((5, 5),)</span>
<span class="sd">    &gt;&gt;&gt; b = ((5, 5),)</span>
<span class="sd">    &gt;&gt;&gt; broadcast_chunks(a, b)</span>
<span class="sd">    ((5, 5),)</span>

<span class="sd">    &gt;&gt;&gt; a = ((10, 10, 10), (5, 5),)</span>
<span class="sd">    &gt;&gt;&gt; b = ((5, 5),)</span>
<span class="sd">    &gt;&gt;&gt; broadcast_chunks(a, b)</span>
<span class="sd">    ((10, 10, 10), (5, 5))</span>

<span class="sd">    &gt;&gt;&gt; a = ((10, 10, 10), (5, 5),)</span>
<span class="sd">    &gt;&gt;&gt; b = ((1,), (5, 5),)</span>
<span class="sd">    &gt;&gt;&gt; broadcast_chunks(a, b)</span>
<span class="sd">    ((10, 10, 10), (5, 5))</span>

<span class="sd">    &gt;&gt;&gt; a = ((10, 10, 10), (5, 5),)</span>
<span class="sd">    &gt;&gt;&gt; b = ((3, 3,), (5, 5),)</span>
<span class="sd">    &gt;&gt;&gt; broadcast_chunks(a, b)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: Chunks do not align: [(10, 10, 10), (3, 3)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">chunkss</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunkss</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">chunkss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">chunkss</span><span class="p">))</span>
    <span class="n">chunkss2</span> <span class="o">=</span> <span class="p">[((</span><span class="mi">1</span><span class="p">,),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunkss</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">step1</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunkss2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">step1</span><span class="p">):</span>
            <span class="n">step2</span> <span class="o">=</span> <span class="n">step1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step2</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">step1</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">step2</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Chunks do not align: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">step2</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">store</span><span class="p">(</span>
    <span class="n">sources</span><span class="p">,</span>
    <span class="n">targets</span><span class="p">,</span>
    <span class="n">lock</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">compute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store dask arrays in array-like objects, overwrite data in target</span>

<span class="sd">    This stores dask arrays into object that supports numpy-style setitem</span>
<span class="sd">    indexing.  It stores values chunk by chunk so that it does not have to</span>
<span class="sd">    fill up memory.  For best performance you can align the block size of</span>
<span class="sd">    the storage target with the block size of your array.</span>

<span class="sd">    If your data fits in memory then you may prefer calling</span>
<span class="sd">    ``np.array(myarray)`` instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    sources: Array or iterable of Arrays</span>
<span class="sd">    targets: array-like or Delayed or iterable of array-likes and/or Delayeds</span>
<span class="sd">        These should support setitem syntax ``target[10:20] = ...``</span>
<span class="sd">    lock: boolean or threading.Lock, optional</span>
<span class="sd">        Whether or not to lock the data stores while storing.</span>
<span class="sd">        Pass True (lock each file individually), False (don&#39;t lock) or a</span>
<span class="sd">        particular ``threading.Lock`` object to be shared among all writes.</span>
<span class="sd">    regions: tuple of slices or list of tuples of slices</span>
<span class="sd">        Each ``region`` tuple in ``regions`` should be such that</span>
<span class="sd">        ``target[region].shape = source.shape``</span>
<span class="sd">        for the corresponding source and target in sources and targets,</span>
<span class="sd">        respectively. If this is a tuple, the contents will be assumed to be</span>
<span class="sd">        slices, so do not provide a tuple of tuples.</span>
<span class="sd">    compute: boolean, optional</span>
<span class="sd">        If true compute immediately, return ``dask.delayed.Delayed`` otherwise</span>
<span class="sd">    return_stored: boolean, optional</span>
<span class="sd">        Optionally return the stored result (default False).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ...  # doctest: +SKIP</span>

<span class="sd">    &gt;&gt;&gt; import h5py  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; f = h5py.File(&#39;myfile.hdf5&#39;, mode=&#39;a&#39;)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; dset = f.create_dataset(&#39;/data&#39;, shape=x.shape,</span>
<span class="sd">    ...                                  chunks=x.chunks,</span>
<span class="sd">    ...                                  dtype=&#39;f8&#39;)  # doctest: +SKIP</span>

<span class="sd">    &gt;&gt;&gt; store(x, dset)  # doctest: +SKIP</span>

<span class="sd">    Alternatively store many arrays at the same time</span>

<span class="sd">    &gt;&gt;&gt; store([x, y, z], [dset1, dset2, dset3])  # doctest: +SKIP</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">sources</span><span class="p">]</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">targets</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All sources must be dask array objects&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Different number of sources [</span><span class="si">%d</span><span class="s2">] and targets [</span><span class="si">%d</span><span class="s2">]&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="n">regions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="p">[</span><span class="n">regions</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">regions</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">regions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Different number of sources [</span><span class="si">%d</span><span class="s2">] and targets [</span><span class="si">%d</span><span class="s2">] than regions [</span><span class="si">%d</span><span class="s2">]&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">regions</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="c1"># Optimize all sources together</span>
    <span class="n">sources_dsk</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">])</span>
    <span class="n">sources_dsk</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="n">__dask_optimize__</span><span class="p">(</span>
        <span class="n">sources_dsk</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="n">sources2</span> <span class="o">=</span> <span class="p">[</span><span class="n">Array</span><span class="p">(</span><span class="n">sources_dsk</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">]</span>

    <span class="c1"># Optimize all targets together</span>
    <span class="n">targets2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">targets_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">targets_dsk</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Delayed</span><span class="p">):</span>
            <span class="n">targets2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="n">targets_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">())</span>
            <span class="n">targets_dsk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">is_dask_collection</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Targets must be either Delayed objects or array-likes&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">targets2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="n">targets_dsk</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">targets_dsk</span><span class="p">)</span>
    <span class="n">targets_dsk</span> <span class="o">=</span> <span class="n">Delayed</span><span class="o">.</span><span class="n">__dask_optimize__</span><span class="p">(</span><span class="n">targets_dsk</span><span class="p">,</span> <span class="n">targets_keys</span><span class="p">)</span>

    <span class="n">load_stored</span> <span class="o">=</span> <span class="n">return_stored</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">compute</span>
    <span class="n">toks</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">))]</span>
    <span class="n">store_dsk</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="o">*</span><span class="p">[</span>
            <span class="n">insert_to_ooc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">return_stored</span><span class="p">,</span> <span class="n">load_stored</span><span class="p">,</span> <span class="n">tok</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tok</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sources2</span><span class="p">,</span> <span class="n">targets2</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">toks</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">store_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">store_dsk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">store_dsk</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">store_dsk</span><span class="p">,</span> <span class="n">targets_dsk</span><span class="p">,</span> <span class="n">sources_dsk</span><span class="p">)</span>
    <span class="n">store_dsk</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">store_dsk</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">store_dsk</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">return_stored</span><span class="p">:</span>
        <span class="n">load_store_dsk</span> <span class="o">=</span> <span class="n">store_dsk</span>
        <span class="k">if</span> <span class="n">compute</span><span class="p">:</span>
            <span class="n">store_dlyds</span> <span class="o">=</span> <span class="p">[</span><span class="n">Delayed</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">store_dsk</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">store_keys</span><span class="p">]</span>
            <span class="n">store_dlyds</span> <span class="o">=</span> <span class="n">persist</span><span class="p">(</span><span class="o">*</span><span class="n">store_dlyds</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">store_dsk_2</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">dask</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">store_dlyds</span><span class="p">])</span>

            <span class="n">load_store_dsk</span> <span class="o">=</span> <span class="n">retrieve_from_ooc</span><span class="p">(</span><span class="n">store_keys</span><span class="p">,</span> <span class="n">store_dsk</span><span class="p">,</span> <span class="n">store_dsk_2</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">Array</span><span class="p">(</span><span class="n">load_store_dsk</span><span class="p">,</span> <span class="s2">&quot;load-store-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">toks</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;store-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>
        <span class="n">dsk</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">merge</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">store_keys</span><span class="p">},</span> <span class="n">store_dsk</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Delayed</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dsk</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compute</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">blockdims_from_blockshape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; blockdims_from_blockshape((10, 10), (4, 3))</span>
<span class="sd">    ((4, 4, 2), (3, 3, 3, 1))</span>
<span class="sd">    &gt;&gt;&gt; blockdims_from_blockshape((10, 0), (4, 0))</span>
<span class="sd">    ((4, 4, 2), (0,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must supply chunks= keyword argument&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must supply shape= keyword argument&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">chunks</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Array chunk sizes are unknown. shape: </span><span class="si">%s</span><span class="s2">, chunks: </span><span class="si">%s%s</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">unknown_chunk_message</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">is_integer</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunks can only contain integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">is_integer</span><span class="p">,</span> <span class="n">shape</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape can only contain integers.&quot;</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">chunks</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="p">((</span><span class="n">bd</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">//</span> <span class="n">bd</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">d</span> <span class="o">%</span> <span class="n">bd</span><span class="p">,)</span> <span class="k">if</span> <span class="n">d</span> <span class="o">%</span> <span class="n">bd</span> <span class="k">else</span> <span class="p">())</span> <span class="k">if</span> <span class="n">d</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">concatenate3</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    <span class="n">results2</span> <span class="o">=</span> <span class="n">results</span>
    <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results2</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concatenate3</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results2</span> <span class="o">=</span> <span class="n">results2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">unpack_singleton</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>


<span class="n">CHUNKS_NONE_ERROR_MESSAGE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">You must specify a chunks= keyword argument.</span>
<span class="s2">This specifies the chunksize of your array blocks.</span>

<span class="s2">See the following documentation page for details:</span>
<span class="s2">  https://docs.dask.org/en/latest/array-creation.html#chunks</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">DaskMethodsMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parallel Dask Array</span>

<span class="sd">    A parallel nd-array comprised of many numpy arrays arranged in a grid.</span>

<span class="sd">    This constructor is for advanced uses only.  For normal use see the</span>
<span class="sd">    ``da.from_array`` function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dask : dict</span>
<span class="sd">        Task dependency graph</span>
<span class="sd">    name : string</span>
<span class="sd">        Name of array in dask</span>
<span class="sd">    shape : tuple of ints</span>
<span class="sd">        Shape of the entire array</span>
<span class="sd">    chunks: iterable of tuples</span>
<span class="sd">        block sizes along each dimension</span>
<span class="sd">    dtype : str or dtype</span>
<span class="sd">        Typecode or data-type for the new Dask Array</span>
<span class="sd">    meta : empty ndarray</span>
<span class="sd">        empty ndarray created with same NumPy backend, ndim and dtype as the</span>
<span class="sd">        Dask Array being created (overrides dtype)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dask.array.from_array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s2">&quot;dask&quot;</span><span class="p">,</span> <span class="s2">&quot;_name&quot;</span><span class="p">,</span> <span class="s2">&quot;_cached_keys&quot;</span><span class="p">,</span> <span class="s2">&quot;_chunks&quot;</span><span class="p">,</span> <span class="s2">&quot;_meta&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dask</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dask</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dask</span><span class="p">,</span> <span class="n">HighLevelGraph</span><span class="p">):</span>
            <span class="n">dask</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dask</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dask</span> <span class="o">=</span> <span class="n">dask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">meta_from_array</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">chunks</span>
            <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chunks</span> <span class="o">=</span> <span class="n">normalize_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">CHUNKS_NONE_ERROR_MESSAGE</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta</span> <span class="o">=</span> <span class="n">meta_from_array</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">plugin</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;array_plugins&quot;</span><span class="p">,</span> <span class="p">()):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">plugin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">result</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__dask_graph__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dask</span>

    <span class="k">def</span> <span class="nf">__dask_layers__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__dask_keys__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_keys</span>

        <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">numblocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numblocks</span>

        <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">chunks</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">name</span><span class="p">,)]</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">numblocks</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numblocks</span><span class="p">[</span><span class="n">ind</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numblocks</span><span class="p">[</span><span class="n">ind</span><span class="p">])]</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_keys</span> <span class="o">=</span> <span class="n">result</span> <span class="o">=</span> <span class="n">keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__dask_tokenize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="n">__dask_optimize__</span> <span class="o">=</span> <span class="n">globalmethod</span><span class="p">(</span>
        <span class="n">optimize</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;array_optimize&quot;</span><span class="p">,</span> <span class="n">falsey</span><span class="o">=</span><span class="n">dont_optimize</span>
    <span class="p">)</span>
    <span class="n">__dask_scheduler__</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">threaded</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dask_postcompute__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">finalize</span><span class="p">,</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__dask_postpersist__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Array</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">numblocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npartitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numblocks</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_chunk_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the chunk sizes for a Dask array. This is especially useful</span>
<span class="sd">        when the chunk sizes are unknown (e.g., when indexing one Dask array</span>
<span class="sd">        with another).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function modifies the Dask array in-place.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; x = da.from_array([-2, -1, 0, 1, 2], chunks=2)</span>
<span class="sd">        &gt;&gt;&gt; x.chunks</span>
<span class="sd">        ((2, 2, 1),)</span>
<span class="sd">        &gt;&gt;&gt; y = x[x &lt;= 0]</span>
<span class="sd">        &gt;&gt;&gt; y.chunks</span>
<span class="sd">        ((nan, nan, nan),)</span>
<span class="sd">        &gt;&gt;&gt; y.compute_chunk_sizes()  # in-place computation</span>
<span class="sd">        dask.array&lt;getitem, shape=(3,), dtype=int64, chunksize=(2,), chunktype=numpy.ndarray&gt;</span>
<span class="sd">        &gt;&gt;&gt; y.chunks</span>
<span class="sd">        ((2, 1, 0),)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">chunk_shapes</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span>
            <span class="n">_get_chunk_shape</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">,),),</span>
            <span class="n">new_axis</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">chunk_shapes</span><span class="p">[</span><span class="n">s</span><span class="p">]))</span>

        <span class="c1"># `map_blocks` assigns numpy dtypes</span>
        <span class="c1"># cast chunk dimensions back to python int before returning</span>
        <span class="n">x</span><span class="o">.</span><span class="n">_chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">])</span> <span class="k">for</span> <span class="n">chunks</span> <span class="ow">in</span> <span class="n">compute</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cached_cumsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">initial_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chunksize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_get_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunks</span>

    <span class="k">def</span> <span class="nf">_set_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunks</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Can not set chunks directly</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Please use the rechunk method instead:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  x.rechunk(</span><span class="si">{}</span><span class="s2">)</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;If trying to avoid unknown chunks, use</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  x.compute_chunk_sizes()&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_chunks</span><span class="p">,</span> <span class="n">_set_chunks</span><span class="p">,</span> <span class="s2">&quot;chunks property&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;len() of unsized object&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numpy_ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="o">+</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_should_delegate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;__call__&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numpy_ufunc</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">matmul</span>

                <span class="c1"># special case until apply_gufunc handles optional dimensions</span>
                <span class="k">return</span> <span class="n">matmul</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy_ufunc</span><span class="o">.</span><span class="n">signature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">.gufunc</span> <span class="kn">import</span> <span class="n">apply_gufunc</span>

                <span class="k">return</span> <span class="n">apply_gufunc</span><span class="p">(</span>
                    <span class="n">numpy_ufunc</span><span class="p">,</span> <span class="n">numpy_ufunc</span><span class="o">.</span><span class="n">signature</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy_ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">ufunc</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">da_ufunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">numpy_ufunc</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
                <span class="k">return</span> <span class="n">da_ufunc</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">numpy_ufunc</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">ufunc</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">da_ufunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">numpy_ufunc</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>
            <span class="k">return</span> <span class="n">da_ufunc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">        &gt;&gt;&gt; da.ones((10, 10), chunks=(5, 5), dtype=&#39;i4&#39;)</span>
<span class="sd">        dask.array&lt;..., shape=(10, 10), dtype=int32, chunksize=(5, 5), chunktype=numpy.ndarray&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;dask.array&lt;</span><span class="si">%s</span><span class="s2">, shape=</span><span class="si">%s</span><span class="s2">, dtype=</span><span class="si">%s</span><span class="s2">, chunksize=</span><span class="si">%s</span><span class="s2">, chunktype=</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_html_table</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_svg</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;array.svg.size&quot;</span><span class="p">,</span> <span class="mi">120</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">both</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;&lt;table&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&lt;tr&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&lt;td&gt;&quot;</span><span class="p">,</span>
            <span class="n">table</span><span class="p">,</span>
            <span class="s2">&quot;&lt;/td&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&lt;td&gt;&quot;</span><span class="p">,</span>
            <span class="n">grid</span><span class="p">,</span>
            <span class="s2">&quot;&lt;/td&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&lt;/tr&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&lt;/table&gt;&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">both</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;sparse&quot;</span> <span class="ow">in</span> <span class="n">typename</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">)):</span>
            <span class="n">nbytes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">cbytes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span><span class="p">):</span>
            <span class="n">nbytes</span> <span class="o">=</span> <span class="n">format_bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)</span>
            <span class="n">cbytes</span> <span class="o">=</span> <span class="n">format_bytes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nbytes</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
            <span class="n">cbytes</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>

        <span class="n">table</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;&lt;table&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;  &lt;thead&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;    &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;th&gt; Array &lt;/th&gt;&lt;th&gt; Chunk &lt;/th&gt;&lt;/tr&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;  &lt;/thead&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;  &lt;tbody&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;    &lt;tr&gt;&lt;th&gt; Bytes &lt;/th&gt;&lt;td&gt; </span><span class="si">%s</span><span class="s2"> &lt;/td&gt; &lt;td&gt; </span><span class="si">%s</span><span class="s2"> &lt;/td&gt;&lt;/tr&gt;&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">cbytes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nbytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;    &lt;tr&gt;&lt;th&gt; Shape &lt;/th&gt;&lt;td&gt; </span><span class="si">%s</span><span class="s2"> &lt;/td&gt; &lt;td&gt; </span><span class="si">%s</span><span class="s2"> &lt;/td&gt;&lt;/tr&gt;&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)),</span>
            <span class="s2">&quot;    &lt;tr&gt;&lt;th&gt; Count &lt;/th&gt;&lt;td&gt; </span><span class="si">%d</span><span class="s2"> Tasks &lt;/td&gt;&lt;td&gt; </span><span class="si">%d</span><span class="s2"> Chunks &lt;/td&gt;&lt;/tr&gt;&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">npartitions</span><span class="p">),</span>
            <span class="s2">&quot;    &lt;tr&gt;&lt;th&gt; Type &lt;/th&gt;&lt;td&gt; </span><span class="si">%s</span><span class="s2"> &lt;/td&gt;&lt;td&gt; </span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2"> &lt;/td&gt;&lt;/tr&gt;&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="s2">&quot;  &lt;/tbody&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&lt;/table&gt;&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of elements in array &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of bytes in array &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Length of one array element in bytes &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">val</span>
        <span class="c1"># Clear the key cache when the name is reset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_keys</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">11</span>  <span class="c1"># higher than numpy.ndarray and numpy.matrix</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">__array_function__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">module</span>

        <span class="k">def</span> <span class="nf">handle_nonmatching_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_HANDLED_FUNCTIONS</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The `</span><span class="si">{}</span><span class="s2">` function is not implemented by Dask array. &quot;</span>
                    <span class="s2">&quot;You may want to use the da.map_blocks function &quot;</span>
                    <span class="s2">&quot;or something similar to silence this warning. &quot;</span>
                    <span class="s2">&quot;Your code may stop working in a future release.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">),</span>
                    <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Need to convert to array object (e.g. numpy.ndarray or</span>
                <span class="c1"># cupy.ndarray) as needed, so we can call the NumPy function</span>
                <span class="c1"># again and it gets the chance to dispatch to the right</span>
                <span class="c1"># implementation.</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">compute</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">_HANDLED_FUNCTIONS</span><span class="p">[</span><span class="n">func</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># First, verify that all types are handled by Dask. Otherwise, return NotImplemented.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span> <span class="ow">is</span> <span class="n">Array</span> <span class="ow">or</span> <span class="n">is_valid_chunk_type</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="k">for</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">types</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># Now try to find a matching function name.  If that doesn&#39;t work, we may</span>
        <span class="c1"># be dealing with an alias or a function that&#39;s simply not in the Dask API.</span>
        <span class="c1"># Handle aliases via the _HANDLED_FUNCTIONS dict mapping, and warn otherwise.</span>
        <span class="k">for</span> <span class="n">submodule</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">submodule</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">handle_nonmatching_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">handle_nonmatching_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">da_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">da_func</span> <span class="ow">is</span> <span class="n">func</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">handle_nonmatching_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">da_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_elemwise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">store</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_stored&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">to_svg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert chunks from Dask Array into an SVG Image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunks: tuple</span>
<span class="sd">        size: int</span>
<span class="sd">            Rough size of the image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x.to_svg(size=500)  # doctest: +SKIP</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        text: An svg string depicting the array as a grid of chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.svg</span> <span class="kn">import</span> <span class="n">svg</span>

        <span class="k">return</span> <span class="n">svg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_hdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store array in HDF5 file</span>

<span class="sd">        &gt;&gt;&gt; x.to_hdf5(&#39;myfile.hdf5&#39;, &#39;/x&#39;)  # doctest: +SKIP</span>

<span class="sd">        Optionally provide arguments as though to ``h5py.File.create_dataset``</span>

<span class="sd">        &gt;&gt;&gt; x.to_hdf5(&#39;myfile.hdf5&#39;, &#39;/x&#39;, compression=&#39;lzf&#39;, shuffle=True)  # doctest: +SKIP</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        da.store</span>
<span class="sd">        h5py.File.create_dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">to_hdf5</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dask_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert dask Array to dask Dataframe</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        columns: list or string</span>
<span class="sd">            list of column names if DataFrame, single string if Series</span>
<span class="sd">        index : dask.dataframe.Index, optional</span>
<span class="sd">            An optional *dask* Index to use for the output Series or DataFrame.</span>

<span class="sd">            The default output index depends on whether the array has any unknown</span>
<span class="sd">            chunks. If there are any unknown chunks, the output has ``None``</span>
<span class="sd">            for all the divisions (one per chunk). If all the chunks are known,</span>
<span class="sd">            a default index with known divsions is created.</span>

<span class="sd">            Specifying ``index`` can be useful if you&#39;re conforming a Dask Array</span>
<span class="sd">            to an existing dask Series or DataFrame, and you would like the</span>
<span class="sd">            indices to match.</span>
<span class="sd">        meta : object, optional</span>
<span class="sd">            An optional `meta` parameter can be passed for dask</span>
<span class="sd">            to specify the concrete dataframe type to use for partitions of</span>
<span class="sd">            the Dask dataframe. By default, pandas DataFrame is used.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.dataframe.from_dask_array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..dataframe</span> <span class="kn">import</span> <span class="n">from_dask_array</span>

        <span class="k">return</span> <span class="n">from_dask_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The truth value of a </span><span class="si">{0}</span><span class="s2"> is ambiguous. &quot;</span>
                <span class="s2">&quot;Use a.any() or a.all().&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>

    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>  <span class="c1"># python 2</span>

    <span class="k">def</span> <span class="nf">_scalarfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cast_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only length-1 arrays can be converted to Python scalars&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalarfunc</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">__long__</span> <span class="o">=</span> <span class="fm">__int__</span>  <span class="c1"># python 2</span>

    <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalarfunc</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalarfunc</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">where</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;boolean index array should have 1 dimension&quot;</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meta</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">_meta</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dask</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">dask</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chunks</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">chunks</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Item assignment with </span><span class="si">%s</span><span class="s2"> not supported&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="c1"># Field access, e.g. x[&#39;a&#39;] or x[[&#39;a&#39;, &#39;b&#39;]]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">_make_sliced_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
                <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">i</span><span class="p">,)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span>
                    <span class="n">getitem</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">new_axis</span><span class="o">=</span><span class="n">new_axis</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">getitem</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span>

        <span class="kn">from</span> <span class="nn">.slicing</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">normalize_index</span><span class="p">,</span>
            <span class="n">slice_with_int_dask_array</span><span class="p">,</span>
            <span class="n">slice_with_bool_dask_array</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">index2</span> <span class="o">=</span> <span class="n">normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
                <span class="n">dependencies</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;iu&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index2</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">slice_with_int_dask_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index2</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">slice_with_bool_dask_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index2</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;getitem-&quot;</span> <span class="o">+</span> <span class="n">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index2</span><span class="p">)</span>
        <span class="n">dsk</span><span class="p">,</span> <span class="n">chunks</span> <span class="o">=</span> <span class="n">slice_array</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dsk</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>

        <span class="n">meta</span> <span class="o">=</span> <span class="n">meta_from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">meta</span><span class="p">):</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_vindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;vindex does not support indexing with None (np.newaxis), &quot;</span>
                <span class="s2">&quot;got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">k</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;vindex requires at least one non-slice to vectorize over &quot;</span>
                <span class="s2">&quot;when the slices are not over the entire array (i.e, x[:]). &quot;</span>
                <span class="s2">&quot;Use normal slicing instead when only using slices. Got: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_vindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vectorized indexing with broadcasting.</span>

<span class="sd">        This is equivalent to numpy&#39;s advanced indexing, using arrays that are</span>
<span class="sd">        broadcast against each other. This allows for pointwise indexing:</span>

<span class="sd">        &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">        &gt;&gt;&gt; x = from_array(x, chunks=2)</span>
<span class="sd">        &gt;&gt;&gt; x.vindex[[0, 1, 2], [0, 1, 2]].compute()</span>
<span class="sd">        array([1, 5, 9])</span>

<span class="sd">        Mixed basic/advanced indexing with slices/arrays is also supported. The</span>
<span class="sd">        order of dimensions in the result follows those proposed for</span>
<span class="sd">        `ndarray.vindex &lt;https://github.com/numpy/numpy/pull/6256&gt;`_:</span>
<span class="sd">        the subspace spanned by arrays is followed by all slices.</span>

<span class="sd">        Note: ``vindex`` provides more general functionality than standard</span>
<span class="sd">        indexing, but it also has fewer optimizations and can be significantly</span>
<span class="sd">        slower.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IndexCallable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vindex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.slicing</span> <span class="kn">import</span> <span class="n">normalize_index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only slice with a single list&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">index</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Slicing with np.newaxis or None is not supported&quot;</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numblocks</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="k">else</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;blocks-&quot;</span> <span class="o">+</span> <span class="n">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

        <span class="n">new_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)[</span><span class="n">index</span><span class="p">]</span>

        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">keys</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">))</span>

        <span class="n">layer</span> <span class="o">=</span> <span class="p">{(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">key</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice an array by blocks</span>

<span class="sd">        This allows blockwise slicing of a Dask array.  You can perform normal</span>
<span class="sd">        Numpy-style slicing but now rather than slice elements of the array you</span>
<span class="sd">        slice along blocks so, for example, ``x.blocks[0, ::2]`` produces a new</span>
<span class="sd">        dask array with every other block in the first row of blocks.</span>

<span class="sd">        You can index blocks in any way that could index a numpy array of shape</span>
<span class="sd">        equal to the number of blocks in each dimension, (available as</span>
<span class="sd">        array.numblocks).  The dimension of the output array will be the same</span>
<span class="sd">        as the dimension of this array, even if integer indices are passed.</span>
<span class="sd">        This does not support slicing with ``np.newaxis`` or multiple lists.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">        &gt;&gt;&gt; x = da.arange(10, chunks=2)</span>
<span class="sd">        &gt;&gt;&gt; x.blocks[0].compute()</span>
<span class="sd">        array([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; x.blocks[:3].compute()</span>
<span class="sd">        array([0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; x.blocks[::2].compute()</span>
<span class="sd">        array([0, 1, 4, 5, 8, 9])</span>
<span class="sd">        &gt;&gt;&gt; x.blocks[[-1, 0]].compute()</span>
<span class="sd">        array([8, 9, 0, 1])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A Dask array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IndexCallable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice an array by partitions. Alias of dask array .blocks attribute.</span>

<span class="sd">        This alias allows you to write agnostic code that works with both</span>
<span class="sd">        dask arrays and dask dataframes.</span>

<span class="sd">        This allows blockwise slicing of a Dask array.  You can perform normal</span>
<span class="sd">        Numpy-style slicing but now rather than slice elements of the array you</span>
<span class="sd">        slice along blocks so, for example, ``x.blocks[0, ::2]`` produces a new</span>
<span class="sd">        dask array with every other block in the first row of blocks.</span>

<span class="sd">        You can index blocks in any way that could index a numpy array of shape</span>
<span class="sd">        equal to the number of blocks in each dimension, (available as</span>
<span class="sd">        array.numblocks).  The dimension of the output array will be the same</span>
<span class="sd">        as the dimension of this array, even if integer indices are passed.</span>
<span class="sd">        This does not support slicing with ``np.newaxis`` or multiple lists.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">        &gt;&gt;&gt; x = da.arange(10, chunks=2)</span>
<span class="sd">        &gt;&gt;&gt; x.partitions[0].compute()</span>
<span class="sd">        array([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; x.partitions[:3].compute()</span>
<span class="sd">        array([0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; x.partitions[::2].compute()</span>
<span class="sd">        array([0, 1, 4, 5, 8, 9])</span>
<span class="sd">        &gt;&gt;&gt; x.partitions[[-1, 0]].compute()</span>
<span class="sd">        array([8, 9, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; all(x.partitions[:].compute() == x.blocks[:].compute())</span>
<span class="sd">        True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A Dask array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">tensordot</span>

        <span class="k">return</span> <span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">transpose</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">axes</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">axes</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">0</span><span class="p">))):</span>
            <span class="c1"># no transpose necessary</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">ravel</span>

        <span class="k">return</span> <span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">flatten</span> <span class="o">=</span> <span class="n">ravel</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">choose</span>

        <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reshape</span> <span class="kn">import</span> <span class="n">reshape</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Number</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">topk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The top k elements of an array.</span>

<span class="sd">        See ``da.topk`` for docstring&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">topk</span>

        <span class="k">return</span> <span class="n">topk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argtopk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The indices of the top k elements of an array.</span>

<span class="sd">        See ``da.argtopk`` for docstring&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">argtopk</span>

        <span class="k">return</span> <span class="n">argtopk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy of the array, cast to a specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or dtype</span>
<span class="sd">            Typecode or data-type to which the array is cast.</span>
<span class="sd">        casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span>
<span class="sd">            Controls what kind of data casting may occur. Defaults to &#39;unsafe&#39;</span>
<span class="sd">            for backwards compatibility.</span>

<span class="sd">            * &#39;no&#39; means the data types should not be cast at all.</span>
<span class="sd">            * &#39;equiv&#39; means only byte-order changes are allowed.</span>
<span class="sd">            * &#39;safe&#39; means only casts which can preserve values are allowed.</span>
<span class="sd">            * &#39;same_kind&#39; means only safe casts or casts within a kind,</span>
<span class="sd">                like float64 to float32, are allowed.</span>
<span class="sd">            * &#39;unsafe&#39; means any data conversions may be done.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            By default, astype always returns a newly allocated array. If this</span>
<span class="sd">            is set to False and the `dtype` requirement is satisfied, the input</span>
<span class="sd">            array is returned instead of a copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Scalars don&#39;t take `casting` or `copy` kwargs - as such we only pass</span>
        <span class="c1"># them to `map_blocks` if specified by user (different than defaults).</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;casting&quot;</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">extra</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;astype does not take the following keyword &quot;</span>
                <span class="s2">&quot;arguments: </span><span class="si">{0!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">extra</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">casting</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;casting&quot;</span><span class="p">,</span> <span class="s2">&quot;unsafe&quot;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot cast array from </span><span class="si">{0!r}</span><span class="s2"> to </span><span class="si">{1!r}</span><span class="s2">&quot;</span>
                <span class="s2">&quot; according to the rule &quot;</span>
                <span class="s2">&quot;</span><span class="si">{2!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">astype</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">astype_dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">div</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">div</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">invert</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lshift</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lshift</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">rshift</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">rshift</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">elemwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">matmul</span>

        <span class="k">return</span> <span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">matmul</span>

        <span class="k">return</span> <span class="n">matmul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.ufunc</span> <span class="kn">import</span> <span class="nb">divmod</span>

        <span class="k">return</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@check_if_handled_given_other</span>
    <span class="k">def</span> <span class="fm">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.ufunc</span> <span class="kn">import</span> <span class="nb">divmod</span>

        <span class="k">return</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="nb">any</span>

        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="nb">all</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="nb">min</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="nb">max</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">argmin</span>

        <span class="k">return</span> <span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">argmax</span>

        <span class="k">return</span> <span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="nb">sum</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">trace</span>

        <span class="k">return</span> <span class="n">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">prod</span>

        <span class="k">return</span> <span class="n">prod</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">mean</span>

        <span class="k">return</span> <span class="n">mean</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">std</span>

        <span class="k">return</span> <span class="n">std</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
            <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">var</span>

        <span class="k">return</span> <span class="n">var</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
            <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">moment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">order</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">split_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the nth centralized moment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : int</span>
<span class="sd">            Order of the moment that is returned, must be &gt;= 2.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which the central moment is computed. The default is to</span>
<span class="sd">            compute the moment of the flattened array.</span>
<span class="sd">        dtype : data-type, optional</span>
<span class="sd">            Type to use in computing the moment. For arrays of integer type the</span>
<span class="sd">            default is float64; for arrays of float types it is the same as the</span>
<span class="sd">            array type.</span>
<span class="sd">        keepdims : bool, optional</span>
<span class="sd">            If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">            result as dimensions with size one. With this option, the result</span>
<span class="sd">            will broadcast correctly against the original array.</span>
<span class="sd">        ddof : int, optional</span>
<span class="sd">            &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is</span>
<span class="sd">            N - ddof, where N represents the number of elements. By default</span>
<span class="sd">            ddof is zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moment : ndarray</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Pebay, Philippe (2008), &quot;Formulas for Robust, One-Pass Parallel</span>
<span class="sd">           Computation of Covariances and Arbitrary-Order Statistical Moments&quot;,</span>
<span class="sd">           Technical Report SAND2008-6212, Sandia National Laboratories.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">moment</span>

        <span class="k">return</span> <span class="n">moment</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">order</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
            <span class="n">split_every</span><span class="o">=</span><span class="n">split_every</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">map_blocks</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">map_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">map_blocks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map a function over blocks of the array with some overlap</span>

<span class="sd">        We share neighboring zones between blocks of the array, then map a</span>
<span class="sd">        function, then trim away the neighboring strips.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func: function</span>
<span class="sd">            The function to apply to each extended block</span>
<span class="sd">        depth: int, tuple, or dict</span>
<span class="sd">            The number of elements that each block should share with its neighbors</span>
<span class="sd">            If a tuple or dict then this can be different per axis</span>
<span class="sd">        boundary: str, tuple, dict</span>
<span class="sd">            How to handle the boundaries.</span>
<span class="sd">            Values include &#39;reflect&#39;, &#39;periodic&#39;, &#39;nearest&#39;, &#39;none&#39;,</span>
<span class="sd">            or any constant value like 0 or np.nan</span>
<span class="sd">        trim: bool</span>
<span class="sd">            Whether or not to trim ``depth`` elements from each block after</span>
<span class="sd">            calling the map function.</span>
<span class="sd">            Set this to False if your mapping function already does this for you</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            Other keyword arguments valid in ``map_blocks``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([1, 1, 2, 3, 3, 3, 2, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; x = from_array(x, chunks=5)</span>
<span class="sd">        &gt;&gt;&gt; def derivative(x):</span>
<span class="sd">        ...     return x - np.roll(x, 1)</span>

<span class="sd">        &gt;&gt;&gt; y = x.map_overlap(derivative, depth=1, boundary=0)</span>
<span class="sd">        &gt;&gt;&gt; y.compute()</span>
<span class="sd">        array([ 1,  0,  1,  1,  0,  0, -1, -1,  0])</span>

<span class="sd">        &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">        &gt;&gt;&gt; x = np.arange(16).reshape((4, 4))</span>
<span class="sd">        &gt;&gt;&gt; d = da.from_array(x, chunks=(2, 2))</span>
<span class="sd">        &gt;&gt;&gt; d.map_overlap(lambda x: x + x.size, depth=1).compute()</span>
<span class="sd">        array([[16, 17, 18, 19],</span>
<span class="sd">               [20, 21, 22, 23],</span>
<span class="sd">               [24, 25, 26, 27],</span>
<span class="sd">               [28, 29, 30, 31]])</span>

<span class="sd">        &gt;&gt;&gt; func = lambda x: x + x.size</span>
<span class="sd">        &gt;&gt;&gt; depth = {0: 1, 1: 1}</span>
<span class="sd">        &gt;&gt;&gt; boundary = {0: &#39;reflect&#39;, 1: &#39;none&#39;}</span>
<span class="sd">        &gt;&gt;&gt; d.map_overlap(func, depth, boundary).compute()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        array([[12,  13,  14,  15],</span>
<span class="sd">               [16,  17,  18,  19],</span>
<span class="sd">               [20,  21,  22,  23],</span>
<span class="sd">               [24,  25,  26,  27]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.overlap</span> <span class="kn">import</span> <span class="n">map_overlap</span>

        <span class="k">return</span> <span class="n">map_overlap</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="n">trim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">cumsum</span>

        <span class="k">return</span> <span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.reductions</span> <span class="kn">import</span> <span class="n">cumprod</span>

        <span class="k">return</span> <span class="n">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">squeeze</span>

        <span class="k">return</span> <span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rechunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">block_size_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; See da.rechunk for docstring &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">rechunk</span>  <span class="c1"># avoid circular import</span>

        <span class="k">return</span> <span class="n">rechunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">block_size_limit</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.ufunc</span> <span class="kn">import</span> <span class="n">real</span>

        <span class="k">return</span> <span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.ufunc</span> <span class="kn">import</span> <span class="n">imag</span>

        <span class="k">return</span> <span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.ufunc</span> <span class="kn">import</span> <span class="n">conj</span>

        <span class="k">return</span> <span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.ufunc</span> <span class="kn">import</span> <span class="n">clip</span>

        <span class="k">return</span> <span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a view of the array as a new data type</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype:</span>
<span class="sd">            The dtype by which to view the array.</span>
<span class="sd">            The default, None, results in the view having the same data-type</span>
<span class="sd">            as the original array.</span>
<span class="sd">        order: string</span>
<span class="sd">            &#39;C&#39; or &#39;F&#39; (Fortran) ordering</span>

<span class="sd">        This reinterprets the bytes of the array under a new dtype.  If that</span>
<span class="sd">        dtype does not have the same size as the original array then the shape</span>
<span class="sd">        will change.</span>

<span class="sd">        Beware that both numpy and dask.array can behave oddly when taking</span>
<span class="sd">        shape-changing views of arrays under Fortran ordering.  Under some</span>
<span class="sd">        versions of NumPy this function will fail when taking shape-changing</span>
<span class="sd">        views of Fortran ordered arrays if the first dimension has chunks of</span>
<span class="sd">        size one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">/</span> <span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>

        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">ensure_int</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">ensure_int</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Order must be one of &#39;C&#39; or &#39;F&#39;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">view</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span>
        <span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">swapaxes</span>

        <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="nb">round</span>

        <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy array.  This is a no-op for dask.arrays, which are immutable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npartitions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">to_delayed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimize_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert into an array of ``dask.delayed`` objects, one per chunk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        optimize_graph : bool, optional</span>
<span class="sd">            If True [default], the graph is optimized before converting into</span>
<span class="sd">            ``dask.delayed`` objects.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dask.array.from_delayed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">optimize_graph</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dask_optimize__</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>  <span class="c1"># TODO, don&#39;t collape graph</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;delayed-&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">())</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">ndeepmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">Delayed</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">graph</span><span class="p">),</span> <span class="n">keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.creation</span> <span class="kn">import</span> <span class="n">repeat</span>

        <span class="k">return</span> <span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.routines</span> <span class="kn">import</span> <span class="n">nonzero</span>

        <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_zarr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save array to the zarr storage format</span>

<span class="sd">        See https://zarr.readthedocs.io for details about the format.</span>

<span class="sd">        See function ``to_zarr()`` for parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">to_zarr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_tiledb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save array to the TileDB storage manager</span>

<span class="sd">        See function ``to_tiledb()`` for argument documentation.</span>

<span class="sd">        See https://docs.tiledb.io for details about the format and engine.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.tiledb_io</span> <span class="kn">import</span> <span class="n">to_tiledb</span>

        <span class="k">return</span> <span class="n">to_tiledb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ensure_int</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not coerce </span><span class="si">%f</span><span class="s2"> to integer&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span>


<span class="k">def</span> <span class="nf">normalize_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">previous_chunks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize chunks to tuple of tuples</span>

<span class="sd">    This takes in a variety of input types and information and produces a full</span>
<span class="sd">    tuple-of-tuples result for chunks, suitable to be passed to Array or</span>
<span class="sd">    rechunk or any other operation that creates a Dask array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chunks: tuple, int, dict, or string</span>
<span class="sd">        The chunks to be normalized.  See examples below for more details</span>
<span class="sd">    shape: Tuple[int]</span>
<span class="sd">        The shape of the array</span>
<span class="sd">    limit: int (optional)</span>
<span class="sd">        The maximum block size to target in bytes,</span>
<span class="sd">        if freedom is given to choose</span>
<span class="sd">    dtype: np.dtype</span>
<span class="sd">    previous_chunks: Tuple[Tuple[int]] optional</span>
<span class="sd">        Chunks from a previous array that we should use for inspiration when</span>
<span class="sd">        rechunking auto dimensions.  If not provided but auto-chunking exists</span>
<span class="sd">        then auto-dimensions will prefer square-like chunk shapes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Specify uniform chunk sizes</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks((2, 2), shape=(5, 6))</span>
<span class="sd">    ((2, 2, 1), (2, 2, 2))</span>

<span class="sd">    Also passes through fully explicit tuple-of-tuples</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks(((2, 2, 1), (2, 2, 2)), shape=(5, 6))</span>
<span class="sd">    ((2, 2, 1), (2, 2, 2))</span>

<span class="sd">    Cleans up lists to tuples</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks([[2, 2], [3, 3]])</span>
<span class="sd">    ((2, 2), (3, 3))</span>

<span class="sd">    Expands integer inputs 10 -&gt; (10, 10)</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks(10, shape=(30, 5))</span>
<span class="sd">    ((10, 10, 10), (5,))</span>

<span class="sd">    Expands dict inputs</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks({0: 2, 1: 3}, shape=(6, 6))</span>
<span class="sd">    ((2, 2, 2), (3, 3))</span>

<span class="sd">    The values -1 and None get mapped to full size</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks((5, -1), shape=(10, 10))</span>
<span class="sd">    ((5, 5), (10,))</span>

<span class="sd">    Use the value &quot;auto&quot; to automatically determine chunk sizes along certain</span>
<span class="sd">    dimensions.  This uses the ``limit=`` and ``dtype=`` keywords to</span>
<span class="sd">    determine how large to make the chunks.  The term &quot;auto&quot; can be used</span>
<span class="sd">    anywhere an integer can be used.  See array chunking documentation for more</span>
<span class="sd">    information.</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks((&quot;auto&quot;,), shape=(20,), limit=5, dtype=&#39;uint8&#39;)</span>
<span class="sd">    ((5, 5, 5, 5),)</span>

<span class="sd">    You can also use byte sizes (see ``dask.utils.parse_bytes``) in place of</span>
<span class="sd">    &quot;auto&quot; to ask for a particular size</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks(&quot;1kiB&quot;, shape=(2000,), dtype=&#39;float32&#39;)</span>
<span class="sd">    ((250, 250, 250, 250, 250, 250, 250, 250),)</span>

<span class="sd">    Respects null dimensions</span>

<span class="sd">    &gt;&gt;&gt; normalize_chunks((), shape=(0, 0))</span>
<span class="sd">    ((0,), (0,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">CHUNKS_NONE_ERROR_MESSAGE</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunks</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">chunks</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">chunks</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,),)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">shape</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">Number</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunks</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">shape</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Chunks and shape must be of the same length/dimension. &quot;</span>
            <span class="s2">&quot;Got chunks=</span><span class="si">%s</span><span class="s2">, shape=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">chunks</span> <span class="ow">or</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span> <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>

    <span class="c1"># If specifying chunk size in bytes, use that value to set the limit.</span>
    <span class="c1"># Verify there is only one consistent value of limit or chunk-bytes used.</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">parsed</span> <span class="o">=</span> <span class="n">parse_bytes</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">parsed</span>
            <span class="k">elif</span> <span class="n">parsed</span> <span class="o">!=</span> <span class="n">limit</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Only one consistent value of limit or chunk is allowed.&quot;</span>
                    <span class="s2">&quot;Used </span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parsed</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
                <span class="p">)</span>
    <span class="c1"># Substitute byte limits with &#39;auto&#39; now that limit is set.</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s2">&quot;auto&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="s2">&quot;auto&quot;</span> <span class="k">else</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">):</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">auto_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">previous_chunks</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="k">else</span> <span class="n">s</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">chunks</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">blockdims_from_blockshape</span><span class="p">((</span><span class="n">s</span><span class="p">,),</span> <span class="p">(</span><span class="n">c</span><span class="p">,))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
                <span class="k">else</span> <span class="p">(</span><span class="n">c</span><span class="p">,)</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="p">(),</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Empty tuples are not allowed in chunks. Express &quot;</span>
                <span class="s2">&quot;zero length dimensions with 0(s) in chunks&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Input array has </span><span class="si">%d</span><span class="s2"> dimensions but the supplied &quot;</span>
                <span class="s2">&quot;chunks has only </span><span class="si">%d</span><span class="s2"> dimensions&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">c</span> <span class="o">==</span> <span class="n">s</span> <span class="ow">or</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">chunks</span><span class="p">),</span> <span class="n">shape</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Chunks do not add up to shape. &quot;</span>
                <span class="s2">&quot;Got chunks=</span><span class="si">%s</span><span class="s2">, shape=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compute_multiplier</span><span class="p">(</span><span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">largest_block</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function for auto_chunk, to fin how much larger or smaller the ideal</span>
<span class="sd">    chunk size is relative to what we have now.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">limit</span>
        <span class="o">/</span> <span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="o">/</span> <span class="n">largest_block</span>
        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span> <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">auto_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">previous_chunks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine automatic chunks</span>

<span class="sd">    This takes in a chunks value that contains ``&quot;auto&quot;`` values in certain</span>
<span class="sd">    dimensions and replaces those values with concrete dimension sizes that try</span>
<span class="sd">    to get chunks to be of a certain size in bytes, provided by the ``limit=``</span>
<span class="sd">    keyword.  If multiple dimensions are marked as ``&quot;auto&quot;`` then they will</span>
<span class="sd">    all respond to meet the desired byte limit, trying to respect the aspect</span>
<span class="sd">    ratio of their dimensions in ``previous_chunks=``, if given.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chunks: Tuple</span>
<span class="sd">        A tuple of either dimensions or tuples of explicit chunk dimensions</span>
<span class="sd">        Some entries should be &quot;auto&quot;</span>
<span class="sd">    shape: Tuple[int]</span>
<span class="sd">    limit: int, str</span>
<span class="sd">        The maximum allowable size of a chunk in bytes</span>
<span class="sd">    previous_chunks: Tuple[Tuple[int]]</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    normalize_chunks: for full docstring and parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">previous_chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">previous_chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">c</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">c</span><span class="p">,)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">previous_chunks</span>
        <span class="p">)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

    <span class="n">autos</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">autos</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;array.chunk-size&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">parse_bytes</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;DType must be known for auto-chunking&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">hasobject</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Can not use auto rechunking with object dtype. &quot;</span>
            <span class="s2">&quot;We are unable to estimate the size in bytes of object data&quot;</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can not perform automatic rechunking with unknown &quot;</span>
                <span class="s2">&quot;(nan) chunk sizes.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">unknown_chunk_message</span>
            <span class="p">)</span>

    <span class="n">limit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

    <span class="n">largest_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
        <span class="p">[</span><span class="n">cs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">chunks</span> <span class="k">if</span> <span class="n">cs</span> <span class="o">!=</span> <span class="s2">&quot;auto&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">previous_chunks</span><span class="p">:</span>
        <span class="c1"># Base ideal ratio on the median chunk size of the previous chunks</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">previous_chunks</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">autos</span><span class="p">}</span>

        <span class="n">ideal_shape</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">chunk_frequencies</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">(</span><span class="n">previous_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">mode</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">chunk_frequencies</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">previous_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">ideal_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ideal_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># How much larger or smaller the ideal chunk size is relative to what we have now</span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="n">_compute_multiplier</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">largest_block</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="n">last_multiplier</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last_autos</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="n">multiplier</span> <span class="o">!=</span> <span class="n">last_multiplier</span> <span class="ow">or</span> <span class="n">autos</span> <span class="o">!=</span> <span class="n">last_autos</span>
        <span class="p">):</span>  <span class="c1"># while things change</span>
            <span class="n">last_multiplier</span> <span class="o">=</span> <span class="n">multiplier</span>  <span class="c1"># record previous values</span>
            <span class="n">last_autos</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">autos</span><span class="p">)</span>  <span class="c1"># record previous values</span>

            <span class="c1"># Expand or contract each of the dimensions appropriately</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">autos</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ideal_shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">continue</span>
                <span class="n">proposed</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplier</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">autos</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">proposed</span> <span class="o">&gt;</span> <span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>  <span class="c1"># we&#39;ve hit the shape boundary</span>
                    <span class="n">autos</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="n">largest_block</span> <span class="o">*=</span> <span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                    <span class="n">chunks</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">result</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">round_to</span><span class="p">(</span><span class="n">proposed</span><span class="p">,</span> <span class="n">ideal_shape</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>

            <span class="c1"># recompute how much multiplier we have left, repeat</span>
            <span class="n">multiplier</span> <span class="o">=</span> <span class="n">_compute_multiplier</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">largest_block</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">chunks</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span> <span class="o">/</span> <span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">/</span> <span class="n">largest_block</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">autos</span><span class="p">))</span>
        <span class="n">small</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">autos</span> <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">small</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">small</span><span class="p">:</span>
                <span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span>
            <span class="k">return</span> <span class="n">auto_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">autos</span><span class="p">:</span>
            <span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">round_to</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">round_to</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a chunk dimension that is close to an even multiple or factor</span>

<span class="sd">    We want values for c that are nicely aligned with s.</span>

<span class="sd">    If c is smaller than s then we want the largest factor of s that is less than the</span>
<span class="sd">    desired chunk size, but not less than half, which is too much.  If no such</span>
<span class="sd">    factor exists then we just go with the original chunk size and accept an</span>
<span class="sd">    uneven chunk at the end.</span>

<span class="sd">    If c is larger than s then we want the largest multiple of s that is still</span>
<span class="sd">    smaller than c.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># no matching factors within factor of two</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">//</span> <span class="n">s</span> <span class="o">*</span> <span class="n">s</span>


<span class="k">def</span> <span class="nf">_get_chunk_shape</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)]</span>


<span class="k">def</span> <span class="nf">from_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">chunks</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">asarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fancy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">getitem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create dask array from something that looks like an array</span>

<span class="sd">    Input must have a ``.shape``, ``.ndim``, ``.dtype`` and support numpy-style slicing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">    chunks : int, tuple</span>
<span class="sd">        How to chunk the array. Must be one of the following forms:</span>

<span class="sd">        - A blocksize like 1000.</span>
<span class="sd">        - A blockshape like (1000, 1000).</span>
<span class="sd">        - Explicit sizes of all blocks along all dimensions like</span>
<span class="sd">          ((1000, 1000, 500), (400, 400)).</span>
<span class="sd">        - A size in bytes, like &quot;100 MiB&quot; which will choose a uniform</span>
<span class="sd">          block-like shape</span>
<span class="sd">        - The word &quot;auto&quot; which acts like the above, but uses a configuration</span>
<span class="sd">          value ``array.chunk-size`` for the chunk size</span>

<span class="sd">        -1 or None as a blocksize indicate the size of the corresponding</span>
<span class="sd">        dimension.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The key name to use for the array. Defaults to a hash of ``x``.</span>
<span class="sd">        By default, hash uses python&#39;s standard sha1. This behaviour can be</span>
<span class="sd">        changed by installing cityhash, xxhash or murmurhash. If installed,</span>
<span class="sd">        a large-factor speedup can be obtained in the tokenisation step.</span>
<span class="sd">        Use ``name=False`` to generate a random name instead of hashing (fast)</span>

<span class="sd">        .. note::</span>

<span class="sd">           Because this ``name`` is used as the key in task graphs, you should</span>
<span class="sd">           ensure that it uniquely identifies the data contained within. If</span>
<span class="sd">           you&#39;d like to provide a descriptive name that is still unique, combine</span>
<span class="sd">           the descriptive name with :func:`dask.base.tokenize` of the</span>
<span class="sd">           ``array_like``. See :ref:`graphs` for more.</span>

<span class="sd">    lock : bool or Lock, optional</span>
<span class="sd">        If ``x`` doesn&#39;t support concurrent reads then provide a lock here, or</span>
<span class="sd">        pass in True to have dask.array create one for you.</span>
<span class="sd">    asarray : bool, optional</span>
<span class="sd">        If True then call np.asarray on chunks to convert them to numpy arrays.</span>
<span class="sd">        If False then chunks are passed through unchanged.</span>
<span class="sd">        If None (default) then we use True if the ``__array_function__`` method</span>
<span class="sd">        is undefined.</span>
<span class="sd">    fancy : bool, optional</span>
<span class="sd">        If ``x`` doesn&#39;t support fancy indexing (e.g. indexing with lists or</span>
<span class="sd">        arrays) then set to False. Default is True.</span>
<span class="sd">    meta : Array-like, optional</span>
<span class="sd">        The metadata for the resulting dask array.  This is the kind of array</span>
<span class="sd">        that will result from slicing the input array.</span>
<span class="sd">        Defaults to the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; x = h5py.File(&#39;...&#39;)[&#39;/data/path&#39;]  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; a = da.from_array(x, chunks=(1000, 1000))  # doctest: +SKIP</span>

<span class="sd">    If your underlying datastore does not support concurrent reads then include</span>
<span class="sd">    the ``lock=True`` keyword argument or ``lock=mylock`` if you want multiple</span>
<span class="sd">    arrays to coordinate around the same lock.</span>

<span class="sd">    &gt;&gt;&gt; a = da.from_array(x, chunks=(1000, 1000), lock=True)  # doctest: +SKIP</span>

<span class="sd">    If your underlying datastore has a ``.chunks`` attribute (as h5py and zarr</span>
<span class="sd">    datasets do) then a multiple of that chunk shape will be used if you</span>
<span class="sd">    do not provide a chunk shape.</span>

<span class="sd">    &gt;&gt;&gt; a = da.from_array(x, chunks=&#39;auto&#39;)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; a = da.from_array(x, chunks=&#39;100 MiB&#39;)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; a = da.from_array(x)  # doctest: +SKIP</span>

<span class="sd">    If providing a name, ensure that it is unique</span>

<span class="sd">    &gt;&gt;&gt; import dask.base</span>
<span class="sd">    &gt;&gt;&gt; token = dask.base.tokenize(x)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; a = da.from_array(&#39;myarray-&#39; + token)  # doctest: +SKIP</span>

<span class="sd">    Numpy ndarrays are eagerly sliced and then embedded in the graph.</span>

<span class="sd">    &gt;&gt;&gt; import dask.array</span>
<span class="sd">    &gt;&gt;&gt; a = dask.array.from_array(np.array([[1, 2], [3, 4]]), chunks=(1,1))</span>
<span class="sd">    &gt;&gt;&gt; a.dask[a.name, 0, 0][0]</span>
<span class="sd">    array([1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Array is already a dask array. Use &#39;asarray&#39; or &quot;</span> <span class="s2">&quot;&#39;rechunk&#39; instead.&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_dask_collection</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Passing an object to dask.array.from_array which is already a &quot;</span>
            <span class="s2">&quot;Dask collection. This can lead to unexpected behavior.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">asarray</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">asarray</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;__array_function__&quot;</span><span class="p">)</span>

    <span class="n">previous_chunks</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;chunks&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="n">normalize_chunks</span><span class="p">(</span>
        <span class="n">chunks</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">previous_chunks</span><span class="o">=</span><span class="n">previous_chunks</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
        <span class="n">original_name</span> <span class="o">=</span> <span class="s2">&quot;array-original-&quot;</span> <span class="o">+</span> <span class="n">token</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;array-&quot;</span> <span class="o">+</span> <span class="n">token</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">original_name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;array-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">original_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="n">SerializableLock</span><span class="p">()</span>

    <span class="n">is_ndarray</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">is_single_block</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">)</span>
    <span class="c1"># Always use the getter for h5py etc. Not using isinstance(x, np.ndarray)</span>
    <span class="c1"># because np.matrix is a subclass of np.ndarray.</span>
    <span class="k">if</span> <span class="n">is_ndarray</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_single_block</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lock</span><span class="p">:</span>
        <span class="c1"># eagerly slice numpy arrays to prevent memory blowup</span>
        <span class="c1"># GH5367, GH5601</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">slices_from_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">product</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="o">*</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bds</span><span class="p">))</span> <span class="k">for</span> <span class="n">bds</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">))</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span> <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">]</span>
        <span class="n">dsk</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">is_ndarray</span> <span class="ow">and</span> <span class="n">is_single_block</span><span class="p">:</span>
        <span class="c1"># No slicing needed</span>
        <span class="n">dsk</span> <span class="o">=</span> <span class="p">{(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span> <span class="n">x</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">getitem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fancy</span><span class="p">:</span>
                <span class="n">getitem</span> <span class="o">=</span> <span class="n">getter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">getitem</span> <span class="o">=</span> <span class="n">getter_nofancy</span>

        <span class="n">dsk</span> <span class="o">=</span> <span class="n">getem</span><span class="p">(</span>
            <span class="n">original_name</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">,</span>
            <span class="n">getitem</span><span class="o">=</span><span class="n">getitem</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">out_name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">,</span>
            <span class="n">asarray</span><span class="o">=</span><span class="n">asarray</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">dsk</span><span class="p">[</span><span class="n">original_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Workaround for TileDB, its indexing is 1-based,</span>
    <span class="c1"># and doesn&#39;t seems to support 0-length slicing</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;tiledb&quot;</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;_ctx_&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">from_zarr</span><span class="p">(</span>
    <span class="n">url</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">storage_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load array from the zarr storage format</span>

<span class="sd">    See https://zarr.readthedocs.io for details about the format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    url: Zarr Array or str or MutableMapping</span>
<span class="sd">        Location of the data. A URL can include a protocol specifier like s3://</span>
<span class="sd">        for remote data. Can also be any MutableMapping instance, which should</span>
<span class="sd">        be serializable if used in multiple processes.</span>
<span class="sd">    component: str or None</span>
<span class="sd">        If the location is a zarr group rather than an array, this is the</span>
<span class="sd">        subcomponent that should be loaded, something like ``&#39;foo/bar&#39;``.</span>
<span class="sd">    storage_options: dict</span>
<span class="sd">        Any additional parameters for the storage backend (ignored for local</span>
<span class="sd">        paths)</span>
<span class="sd">    chunks: tuple of ints or tuples of ints</span>
<span class="sd">        Passed to ``da.from_array``, allows setting the chunks on</span>
<span class="sd">        initialisation, if the chunking scheme in the on-disc dataset is not</span>
<span class="sd">        optimal for the calculations to follow.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">         An optional keyname for the array.  Defaults to hashing the input</span>
<span class="sd">    kwargs: passed to ``zarr.Array``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">zarr</span>

    <span class="n">storage_options</span> <span class="o">=</span> <span class="n">storage_options</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">zarr</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">url</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..bytes.core</span> <span class="kn">import</span> <span class="n">get_mapper</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="n">get_mapper</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="o">**</span><span class="n">storage_options</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">read_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">component</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="n">url</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">read_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">component</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">chunks</span> <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">z</span><span class="o">.</span><span class="n">chunks</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;from-zarr-&quot;</span> <span class="o">+</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">storage_options</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">from_array</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_zarr</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">,</span>
    <span class="n">url</span><span class="p">,</span>
    <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">storage_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">compute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Save array to the zarr storage format</span>

<span class="sd">    See https://zarr.readthedocs.io for details about the format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr: dask.array</span>
<span class="sd">        Data to store</span>
<span class="sd">    url: Zarr Array or str or MutableMapping</span>
<span class="sd">        Location of the data. A URL can include a protocol specifier like s3://</span>
<span class="sd">        for remote data. Can also be any MutableMapping instance, which should</span>
<span class="sd">        be serializable if used in multiple processes.</span>
<span class="sd">    component: str or None</span>
<span class="sd">        If the location is a zarr group rather than an array, this is the</span>
<span class="sd">        subcomponent that should be created/over-written.</span>
<span class="sd">    storage_options: dict</span>
<span class="sd">        Any additional parameters for the storage backend (ignored for local</span>
<span class="sd">        paths)</span>
<span class="sd">    overwrite: bool</span>
<span class="sd">        If given array already exists, overwrite=False will cause an error,</span>
<span class="sd">        where overwrite=True will replace the existing data.  Note that this</span>
<span class="sd">        check is done at computation time, not during graph creation.</span>
<span class="sd">    compute, return_stored: see ``store()``</span>
<span class="sd">    kwargs: passed to the ``zarr.create()`` function, e.g., compression options</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``arr`` has unknown chunk sizes, which is not supported by Zarr.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dask.array.Array.compute_chunk_sizes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">zarr</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Saving a dask array with unknown chunk sizes is not &quot;</span>
            <span class="s2">&quot;currently supported by Zarr.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">unknown_chunk_message</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">zarr</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">url</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">store</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">zarr</span><span class="o">.</span><span class="n">DictStore</span><span class="p">))</span> <span class="ow">and</span> <span class="s2">&quot;distributed&quot;</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;scheduler&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot store into in memory Zarr Array using &quot;</span>
                <span class="s2">&quot;the Distributed Scheduler.&quot;</span>
            <span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">rechunk</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute</span><span class="o">=</span><span class="n">compute</span><span class="p">,</span> <span class="n">return_stored</span><span class="o">=</span><span class="n">return_stored</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_check_regular_chunks</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">chunks</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Attempt to save array to zarr with irregular &quot;</span>
            <span class="s2">&quot;chunking, please call `arr.rechunk(...)` first.&quot;</span>
        <span class="p">)</span>

    <span class="n">storage_options</span> <span class="o">=</span> <span class="n">storage_options</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..bytes.core</span> <span class="kn">import</span> <span class="n">get_mapper</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="n">get_mapper</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="o">**</span><span class="n">storage_options</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># assume the object passed is already a mapper</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="n">url</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">chunks</span><span class="p">]</span>

    <span class="c1"># The zarr.create function has the side-effect of immediately</span>
    <span class="c1"># creating metadata on disk.  This may not be desired,</span>
    <span class="c1"># particularly if compute=False.  The caller may be creating many</span>
    <span class="c1"># arrays on a slow filesystem, with the desire that any I/O be</span>
    <span class="c1"># sharded across workers (not done serially on the originating</span>
    <span class="c1"># machine).  Or the caller may decide later to not to do this</span>
    <span class="c1"># computation, and so nothing should be written to disk.</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="n">zarr</span><span class="o">.</span><span class="n">create</span><span class="p">)(</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">store</span><span class="o">=</span><span class="n">mapper</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="n">component</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute</span><span class="o">=</span><span class="n">compute</span><span class="p">,</span> <span class="n">return_stored</span><span class="o">=</span><span class="n">return_stored</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_regular_chunks</span><span class="p">(</span><span class="n">chunkset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if the chunks are regular</span>

<span class="sd">    &quot;Regular&quot; in this context means that along every axis, the chunks all</span>
<span class="sd">    have the same size, except the last one, which may be smaller</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chunkset: tuple of tuples of ints</span>
<span class="sd">        From the ``.chunks`` attribute of an ``Array``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    True if chunkset passes, else False</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; arr = da.zeros(10, chunks=(5, ))</span>
<span class="sd">    &gt;&gt;&gt; _check_regular_chunks(arr.chunks)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; arr = da.zeros(10, chunks=((3, 3, 3, 1), ))</span>
<span class="sd">    &gt;&gt;&gt; _check_regular_chunks(arr.chunks)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; arr = da.zeros(10, chunks=((3, 1, 3, 3), ))</span>
<span class="sd">    &gt;&gt;&gt; _check_regular_chunks(arr.chunks)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">chunks</span> <span class="ow">in</span> <span class="n">chunkset</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chunks</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">from_delayed</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a dask array from a dask delayed value</span>

<span class="sd">    This routine is useful for constructing dask arrays in an ad-hoc fashion</span>
<span class="sd">    using dask delayed, particularly when combined with stack and concatenate.</span>

<span class="sd">    The dask array will consist of a single chunk.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dask</span>
<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; value = dask.delayed(np.ones)(5)</span>
<span class="sd">    &gt;&gt;&gt; array = da.from_delayed(value, (5,), dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; array</span>
<span class="sd">    dask.array&lt;from-value, shape=(5,), dtype=float64, chunksize=(5,), chunktype=numpy.ndarray&gt;</span>
<span class="sd">    &gt;&gt;&gt; array.compute()</span>
<span class="sd">    array([1., 1., 1., 1., 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..delayed</span> <span class="kn">import</span> <span class="n">delayed</span><span class="p">,</span> <span class="n">Delayed</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Delayed</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;from-value-&quot;</span> <span class="o">+</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span>
    <span class="n">dsk</span> <span class="o">=</span> <span class="p">{(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span> <span class="n">value</span><span class="o">.</span><span class="n">key</span><span class="p">}</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">d</span><span class="p">,)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
    <span class="c1"># TODO: value._key may not be the name of the layer in value.dask</span>
    <span class="c1"># This should be fixed after we build full expression graphs</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dsk</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="n">value</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">from_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
    <span class="sd">&quot;&quot;&quot;Create dask array in a single block by calling a function</span>

<span class="sd">    Calling the provided function with func(*args, **kwargs) should return a</span>
<span class="sd">    NumPy array of the indicated shape and dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; a = from_func(np.arange, (3,), dtype=&#39;i8&#39;, args=(3,))</span>
<span class="sd">    &gt;&gt;&gt; a.compute()</span>
<span class="sd">    array([0, 1, 2])</span>

<span class="sd">    This works particularly well when coupled with dask.array functions like</span>
<span class="sd">    concatenate and stack:</span>

<span class="sd">    &gt;&gt;&gt; arrays = [from_func(np.array, (), dtype=&#39;i8&#39;, args=(n,)) for n in range(5)]</span>
<span class="sd">    &gt;&gt;&gt; stack(arrays).compute()</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;from_func-&quot;</span> <span class="o">+</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">args</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">dsk</span> <span class="o">=</span> <span class="p">{(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span> <span class="p">(</span><span class="n">func</span><span class="p">,)}</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">i</span><span class="p">,)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">common_blockdim</span><span class="p">(</span><span class="n">blockdims</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the common block dimensions from the list of block dimensions</span>

<span class="sd">    Currently only implements the simplest possible heuristic: the common</span>
<span class="sd">    block-dimension is the only one that does not span fully span a dimension.</span>
<span class="sd">    This is a conservative choice that allows us to avoid potentially very</span>
<span class="sd">    expensive rechunking.</span>

<span class="sd">    Assumes that each element of the input block dimensions has all the same</span>
<span class="sd">    sum (i.e., that they correspond to dimensions of the same size).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; common_blockdim([(3,), (2, 1)])</span>
<span class="sd">    (2, 1)</span>
<span class="sd">    &gt;&gt;&gt; common_blockdim([(1, 2), (2, 1)])</span>
<span class="sd">    (1, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; common_blockdim([(2, 2), (3, 1)])  # doctest: +SKIP</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: Chunks do not align</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">blockdims</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">()</span>
    <span class="n">non_trivial_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">blockdims</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_trivial_dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">non_trivial_dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_trivial_dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">blockdims</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">first</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">blockdims</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Arrays chunk sizes (</span><span class="si">%s</span><span class="s2">) are unknown.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;A possible solution:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;  x.compute_chunk_sizes()&quot;</span> <span class="o">%</span> <span class="n">blockdims</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">non_trivial_dims</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Chunks do not add up to same value&quot;</span><span class="p">,</span> <span class="n">blockdims</span><span class="p">)</span>

    <span class="c1"># We have multiple non-trivial chunks on this axis</span>
    <span class="c1"># e.g. (5, 2) and (4, 3)</span>

    <span class="c1"># We create a single chunk tuple with the same total length</span>
    <span class="c1"># that evenly divides both, e.g. (4, 1, 2)</span>

    <span class="c1"># To accomplish this we walk down all chunk tuples together, finding the</span>
    <span class="c1"># smallest element, adding it to the output, and subtracting it from all</span>
    <span class="c1"># other elements and remove the element itself.  We stop once we have</span>
    <span class="c1"># burned through all of the chunk tuples.</span>
    <span class="c1"># For efficiency&#39;s sake we reverse the lists so that we can pop off the end</span>
    <span class="n">rchunks</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ntd</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ntd</span> <span class="ow">in</span> <span class="n">non_trivial_dims</span><span class="p">]</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">non_trivial_dims</span><span class="p">))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rchunks</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rchunks</span><span class="p">:</span>
            <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">m</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="n">m</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unify_chunks</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unify chunks across a sequence of arrays</span>

<span class="sd">    This utility function is used within other common operations like</span>
<span class="sd">    ``map_blocks`` and ``blockwise``.  It is not commonly used by end-users</span>
<span class="sd">    directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args: sequence of Array, index pairs</span>
<span class="sd">        Sequence like (x, &#39;ij&#39;, y, &#39;jk&#39;, z, &#39;i&#39;)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; x = da.ones(10, chunks=((5, 2, 3),))</span>
<span class="sd">    &gt;&gt;&gt; y = da.ones(10, chunks=((2, 3, 5),))</span>
<span class="sd">    &gt;&gt;&gt; chunkss, arrays = unify_chunks(x, &#39;i&#39;, y, &#39;i&#39;)</span>
<span class="sd">    &gt;&gt;&gt; chunkss</span>
<span class="sd">    {&#39;i&#39;: (2, 3, 2, 3)}</span>

<span class="sd">    &gt;&gt;&gt; x = da.ones((100, 10), chunks=(20, 5))</span>
<span class="sd">    &gt;&gt;&gt; y = da.ones((10, 100), chunks=(4, 50))</span>
<span class="sd">    &gt;&gt;&gt; chunkss, arrays = unify_chunks(x, &#39;ij&#39;, y, &#39;jk&#39;, &#39;constant&#39;, None)</span>
<span class="sd">    &gt;&gt;&gt; chunkss  # doctest: +SKIP</span>
<span class="sd">    {&#39;k&#39;: (50, 50), &#39;i&#39;: (20, 20, 20, 20, 20), &#39;j&#39;: (4, 1, 3, 2)}</span>

<span class="sd">    &gt;&gt;&gt; unify_chunks(0, None)</span>
<span class="sd">    ({}, [0])</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chunkss : dict</span>
<span class="sd">        Map like {index: chunks}.</span>
<span class="sd">    arrays : list</span>
<span class="sd">        List of rechunked arrays.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    common_blockdim</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{},</span> <span class="p">[]</span>

    <span class="n">arginds</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">]</span>  <span class="c1"># [x, ij, y, jk]</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">arginds</span><span class="p">))</span>  <span class="c1"># [(x, ij), (y, jk)]</span>
    <span class="n">warn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;warn&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="n">arrays</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arginds</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{},</span> <span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="o">==</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">)),</span> <span class="n">arrays</span>

    <span class="n">nameinds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">blockdim_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">max_parts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">arginds</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nameinds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ind</span><span class="p">))</span>
            <span class="n">blockdim_dict</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span>
            <span class="n">max_parts</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_parts</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">npartitions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nameinds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="p">))</span>

    <span class="n">chunkss</span> <span class="o">=</span> <span class="n">broadcast_dimensions</span><span class="p">(</span><span class="n">nameinds</span><span class="p">,</span> <span class="n">blockdim_dict</span><span class="p">,</span> <span class="n">consolidate</span><span class="o">=</span><span class="n">common_blockdim</span><span class="p">)</span>
    <span class="n">nparts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">chunkss</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

    <span class="k">if</span> <span class="n">warn</span> <span class="ow">and</span> <span class="n">nparts</span> <span class="ow">and</span> <span class="n">nparts</span> <span class="o">&gt;=</span> <span class="n">max_parts</span> <span class="o">*</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Increasing number of chunks by factor of </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nparts</span> <span class="o">/</span> <span class="n">max_parts</span><span class="p">),</span>
            <span class="n">PerformanceWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arginds</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">chunkss</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">chunkss</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="k">else</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">chunks</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">):</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rechunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chunkss</span><span class="p">,</span> <span class="n">arrays</span>


<span class="k">def</span> <span class="nf">unpack_singleton</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; unpack_singleton([[[[1]]]])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; unpack_singleton(np.array(np.datetime64(&#39;2000-01-01&#39;)))</span>
<span class="sd">    array(&#39;2000-01-01&#39;, dtype=&#39;datetime64[D]&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">allow_unknown_chunksizes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assemble an nd-array from nested lists of blocks.</span>

<span class="sd">    Blocks in the innermost lists are concatenated along the last</span>
<span class="sd">    dimension (-1), then these are concatenated along the second-last</span>
<span class="sd">    dimension (-2), and so on until the outermost list is reached</span>

<span class="sd">    Blocks can be of any dimension, but will not be broadcasted using the normal</span>
<span class="sd">    rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``</span>
<span class="sd">    the same for all blocks. This is primarily useful for working with scalars,</span>
<span class="sd">    and means that code like ``block([v, 1])`` is valid, where</span>
<span class="sd">    ``v.ndim == 1``.</span>

<span class="sd">    When the nested list is two levels deep, this allows block matrices to be</span>
<span class="sd">    constructed from their components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : nested list of array_like or scalars (but not tuples)</span>
<span class="sd">        If passed a single ndarray or scalar (a nested list of depth 0), this</span>
<span class="sd">        is returned unmodified (and not copied).</span>

<span class="sd">        Elements shapes must match along the appropriate axes (without</span>
<span class="sd">        broadcasting), but leading 1s will be prepended to the shape as</span>
<span class="sd">        necessary to make the dimensions match.</span>

<span class="sd">    allow_unknown_chunksizes: bool</span>
<span class="sd">        Allow unknown chunksizes, such as come from converting from dask</span>
<span class="sd">        dataframes.  Dask.array is unable to verify that chunks line up.  If</span>
<span class="sd">        data comes from differently aligned sources then this can cause</span>
<span class="sd">        unexpected results.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    block_array : ndarray</span>
<span class="sd">        The array assembled from the given blocks.</span>

<span class="sd">        The dimensionality of the output is equal to the greatest of:</span>
<span class="sd">        * the dimensionality of all the inputs</span>
<span class="sd">        * the depth to which the input list is nested</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        * If list depths are mismatched - for instance, ``[[a, b], c]`` is</span>
<span class="sd">          illegal, and should be spelt ``[[a, b], [c]]``</span>
<span class="sd">        * If lists are empty - for instance, ``[[a, b], []]``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    concatenate : Join a sequence of arrays together.</span>
<span class="sd">    stack : Stack arrays in sequence along a new dimension.</span>
<span class="sd">    hstack : Stack arrays in sequence horizontally (column wise).</span>
<span class="sd">    vstack : Stack arrays in sequence vertically (row wise).</span>
<span class="sd">    dstack : Stack arrays in sequence depth wise (along third dimension).</span>
<span class="sd">    vsplit : Split array into a list of multiple sub-arrays vertically.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    When called with only scalars, ``block`` is equivalent to an ndarray</span>
<span class="sd">    call. So ``block([[1, 2], [3, 4]])`` is equivalent to</span>
<span class="sd">    ``array([[1, 2], [3, 4]])``.</span>

<span class="sd">    This function does not enforce that the blocks lie on a fixed grid.</span>
<span class="sd">    ``block([[a, b], [c, d]])`` is not restricted to arrays of the form::</span>

<span class="sd">        AAAbb</span>
<span class="sd">        AAAbb</span>
<span class="sd">        cccDD</span>

<span class="sd">    But is also allowed to produce, for some ``a, b, c, d``::</span>

<span class="sd">        AAAbb</span>
<span class="sd">        AAAbb</span>
<span class="sd">        cDDDD</span>

<span class="sd">    Since concatenation happens along the last axis first, `block` is _not_</span>
<span class="sd">    capable of producing the following directly::</span>

<span class="sd">        AAAbb</span>
<span class="sd">        cccbb</span>
<span class="sd">        cccDD</span>

<span class="sd">    Matlab&#39;s &quot;square bracket stacking&quot;, ``[A, B, ...; p, q, ...]``, is</span>
<span class="sd">    equivalent to ``block([[A, B, ...], [p, q, ...]])``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This was copied almost verbatim from numpy.core.shape_base.block</span>
    <span class="c1"># See numpy license at https://github.com/numpy/numpy/blob/master/LICENSE.txt</span>
    <span class="c1"># or NUMPY_LICENSE.txt within this directory</span>

    <span class="k">def</span> <span class="nf">atleast_nd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndim</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,)]</span>

    <span class="k">def</span> <span class="nf">format_index</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;arrays&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">)</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="n">_Recurser</span><span class="p">(</span><span class="n">recurse_if</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">)</span>

    <span class="c1"># ensure that the lists are all matched in depth</span>
    <span class="n">list_ndim</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">any_empty</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">entering</span> <span class="ow">in</span> <span class="n">rec</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="c1"># not strictly necessary, but saves us from:</span>
            <span class="c1">#  - more than one way to do things - no point treating tuples like</span>
            <span class="c1">#    lists</span>
            <span class="c1">#  - horribly confusing behaviour that results when tuples are</span>
            <span class="c1">#    treated like ndarray</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is a tuple. &quot;</span>
                <span class="s2">&quot;Only lists can be used to arrange blocks, and np.block does &quot;</span>
                <span class="s2">&quot;not allow implicit conversion from tuple to ndarray.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">format_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">entering</span><span class="p">:</span>
            <span class="n">curr_depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">any_empty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">list_ndim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">list_ndim</span> <span class="o">!=</span> <span class="n">curr_depth</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;List depths are mismatched. First element was at depth </span><span class="si">{}</span><span class="s2">, &quot;</span>
                <span class="s2">&quot;but there is an element at depth </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">list_ndim</span><span class="p">,</span> <span class="n">curr_depth</span><span class="p">,</span> <span class="n">format_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">list_ndim</span> <span class="o">=</span> <span class="n">curr_depth</span>

    <span class="c1"># do this here so we catch depth mismatches first</span>
    <span class="k">if</span> <span class="n">any_empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lists cannot be empty&quot;</span><span class="p">)</span>

    <span class="c1"># convert all the arrays to ndarrays</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">f_map</span><span class="o">=</span><span class="n">asanyarray</span><span class="p">,</span> <span class="n">f_reduce</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

    <span class="c1"># determine the maximum dimension of the elements</span>
    <span class="n">elem_ndim</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">f_map</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">f_reduce</span><span class="o">=</span><span class="nb">max</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">list_ndim</span><span class="p">,</span> <span class="n">elem_ndim</span><span class="p">)</span>

    <span class="c1"># first axis to concatenate along</span>
    <span class="n">first_axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="n">list_ndim</span>

    <span class="c1"># Make all the elements the same dimension</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">(</span>
        <span class="n">arrays</span><span class="p">,</span> <span class="n">f_map</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="n">atleast_nd</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">ndim</span><span class="p">),</span> <span class="n">f_reduce</span><span class="o">=</span><span class="nb">list</span>
    <span class="p">)</span>

    <span class="c1"># concatenate innermost lists on the right, outermost on the left</span>
    <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">(</span>
        <span class="n">arrays</span><span class="p">,</span>
        <span class="n">f_reduce</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xs</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">allow_unknown_chunksizes</span><span class="o">=</span><span class="n">allow_unknown_chunksizes</span>
        <span class="p">),</span>
        <span class="n">f_kwargs</span><span class="o">=</span><span class="k">lambda</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">first_axis</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_unknown_chunksizes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate arrays along an existing axis</span>

<span class="sd">    Given a sequence of dask Arrays form a new dask Array by stacking them</span>
<span class="sd">    along an existing dimension (axis=0 by default)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seq: list of dask.arrays</span>
<span class="sd">    axis: int</span>
<span class="sd">        Dimension along which to align all of the arrays</span>
<span class="sd">    allow_unknown_chunksizes: bool</span>
<span class="sd">        Allow unknown chunksizes, such as come from converting from dask</span>
<span class="sd">        dataframes.  Dask.array is unable to verify that chunks line up.  If</span>
<span class="sd">        data comes from differently aligned sources then this can cause</span>
<span class="sd">        unexpected results.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create slices</span>

<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; data = [from_array(np.ones((4, 4)), chunks=(2, 2))</span>
<span class="sd">    ...          for i in range(3)]</span>

<span class="sd">    &gt;&gt;&gt; x = da.concatenate(data, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (12, 4)</span>

<span class="sd">    &gt;&gt;&gt; da.concatenate(data, axis=1).shape</span>
<span class="sd">    (4, 12)</span>

<span class="sd">    Result is a new dask Array</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stack</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">wrap</span>

    <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need array(s) to concatenate&quot;</span><span class="p">)</span>

    <span class="n">seq_metas</span> <span class="o">=</span> <span class="p">[</span><span class="n">meta_from_array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span>
    <span class="n">_concatenate</span> <span class="o">=</span> <span class="n">concatenate_lookup</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span>
        <span class="nb">type</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">seq_metas</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;__array_priority__&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="p">)</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="n">_concatenate</span><span class="p">(</span><span class="n">seq_metas</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Promote types to match meta</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span>

    <span class="c1"># Find output array shape</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="nb">sum</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Drop empty arrays</span>
    <span class="n">seq2</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq2</span><span class="p">:</span>
        <span class="n">seq2</span> <span class="o">=</span> <span class="n">seq</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="n">ndim</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Axis must be less than than number of dimensions&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Data has </span><span class="si">%d</span><span class="s2"> dimensions, but got axis=</span><span class="si">%d</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">meta</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">meta</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_unknown_chunksizes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">,</span> <span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Tried to concatenate arrays with unknown&quot;</span>
                <span class="s2">&quot; shape </span><span class="si">%s</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">Two solutions:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;  1. Force concatenation pass&quot;</span>
                <span class="s2">&quot; allow_unknown_chunksizes=True.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;  2. Compute shapes with &quot;</span>
                <span class="s2">&quot;[x.compute_chunk_sizes() for x in seq]&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shapes do not align: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">])</span>

    <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
        <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">uc_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">seq2</span><span class="p">,</span> <span class="n">inds</span><span class="p">)))</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">seq2</span> <span class="o">=</span> <span class="n">unify_chunks</span><span class="p">(</span><span class="o">*</span><span class="n">uc_args</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">bds</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
        <span class="o">+</span> <span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">bd</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">bd</span> <span class="ow">in</span> <span class="n">bds</span><span class="p">],</span> <span class="p">()),)</span>
        <span class="o">+</span> <span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
    <span class="p">)</span>

    <span class="n">cum_dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]))</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;concatenate-&quot;</span> <span class="o">+</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">))</span> <span class="k">for</span> <span class="n">bd</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]))</span>

    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">bisect</span><span class="p">(</span><span class="n">cum_dims</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],)</span>
        <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="o">+</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cum_dims</span><span class="p">[</span><span class="n">bisect</span><span class="p">(</span><span class="n">cum_dims</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],)</span>
        <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
    <span class="p">]</span>

    <span class="n">dsk</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dsk</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="n">seq2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load_store_chunk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">return_stored</span><span class="p">,</span> <span class="n">load_stored</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function inserted in a Dask graph for storing a chunk.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: array-like</span>
<span class="sd">        An array (potentially a NumPy one)</span>
<span class="sd">    out: array-like</span>
<span class="sd">        Where to store results too.</span>
<span class="sd">    index: slice-like</span>
<span class="sd">        Where to store result from ``x`` in ``out``.</span>
<span class="sd">    lock: Lock-like or False</span>
<span class="sd">        Lock to use before writing to ``out``.</span>
<span class="sd">    return_stored: bool</span>
<span class="sd">        Whether to return ``out``.</span>
<span class="sd">    load_stored: bool</span>
<span class="sd">        Whether to return the array stored in ``out``.</span>
<span class="sd">        Ignored if ``return_stored`` is not ``True``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; a = np.ones((5, 6))</span>
<span class="sd">    &gt;&gt;&gt; b = np.empty(a.shape)</span>
<span class="sd">    &gt;&gt;&gt; load_store_chunk(a, b, (slice(None), slice(None)), False, False, False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">return_stored</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">load_stored</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">out</span>

    <span class="k">if</span> <span class="n">lock</span><span class="p">:</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_stored</span> <span class="ow">and</span> <span class="n">load_stored</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lock</span><span class="p">:</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">store_chunk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">return_stored</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">load_store_chunk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">return_stored</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load_chunk</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">load_store_chunk</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">insert_to_ooc</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">load_stored</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tok</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a Dask graph for storing chunks from ``arr`` in ``out``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr: da.Array</span>
<span class="sd">        A dask array</span>
<span class="sd">    out: array-like</span>
<span class="sd">        Where to store results too.</span>
<span class="sd">    lock: Lock-like or bool, optional</span>
<span class="sd">        Whether to lock or with what (default is ``True``,</span>
<span class="sd">        which means a ``threading.Lock`` instance).</span>
<span class="sd">    region: slice-like, optional</span>
<span class="sd">        Where in ``out`` to store ``arr``&#39;s results</span>
<span class="sd">        (default is ``None``, meaning all of ``out``).</span>
<span class="sd">    return_stored: bool, optional</span>
<span class="sd">        Whether to return ``out``</span>
<span class="sd">        (default is ``False``, meaning ``None`` is returned).</span>
<span class="sd">    load_stored: bool, optional</span>
<span class="sd">        Whether to handling loading from ``out`` at the same time.</span>
<span class="sd">        Ignored if ``return_stored`` is not ``True``.</span>
<span class="sd">        (default is ``False``, meaning defer to ``return_stored``).</span>
<span class="sd">    tok: str, optional</span>
<span class="sd">        Token to use when naming keys</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; d = da.ones((5, 6), chunks=(2, 3))</span>
<span class="sd">    &gt;&gt;&gt; a = np.empty(d.shape)</span>
<span class="sd">    &gt;&gt;&gt; insert_to_ooc(d, a)  # doctest: +SKIP</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

    <span class="n">slices</span> <span class="o">=</span> <span class="n">slices_from_chunks</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">region</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="n">fuse_slice</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">slc</span><span class="p">)</span> <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">]</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;store-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tok</span> <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">()))</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">store_chunk</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">if</span> <span class="n">return_stored</span> <span class="ow">and</span> <span class="n">load_stored</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;load-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">load_store_chunk</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">load_stored</span><span class="p">,)</span>

    <span class="n">dsk</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">slc</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">return_stored</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">slc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()),</span> <span class="n">slices</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">dsk</span>


<span class="k">def</span> <span class="nf">retrieve_from_ooc</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">dsk_pre</span><span class="p">,</span> <span class="n">dsk_post</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a Dask graph for loading stored ``keys`` from ``dsk``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    keys: Sequence</span>
<span class="sd">        A sequence containing Dask graph keys to load</span>
<span class="sd">    dsk_pre: Mapping</span>
<span class="sd">        A Dask graph corresponding to a Dask Array before computation</span>
<span class="sd">    dsk_post: Mapping, optional</span>
<span class="sd">        A Dask graph corresponding to a Dask Array after computation</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; d = da.ones((5, 6), chunks=(2, 3))</span>
<span class="sd">    &gt;&gt;&gt; a = np.empty(d.shape)</span>
<span class="sd">    &gt;&gt;&gt; g = insert_to_ooc(d, a)</span>
<span class="sd">    &gt;&gt;&gt; retrieve_from_ooc(g.keys(), g)  # doctest: +SKIP</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dsk_post</span><span class="p">:</span>
        <span class="n">dsk_post</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>

    <span class="n">load_dsk</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="s2">&quot;load-&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span> <span class="p">(</span><span class="n">load_chunk</span><span class="p">,</span> <span class="n">dsk_post</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="n">dsk_pre</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">load_dsk</span>


<span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the input to a dask array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like</span>
<span class="sd">        Input data, in any form that can be converted to a dask array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dask array</span>
<span class="sd">        Dask array interpretation of a.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; da.asarray(x)</span>
<span class="sd">    dask.array&lt;array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.ndarray&gt;</span>

<span class="sd">    &gt;&gt;&gt; y = [[1, 2, 3], [4, 5, 6]]</span>
<span class="sd">    &gt;&gt;&gt; da.asarray(y)</span>
<span class="sd">    dask.array&lt;array, shape=(2, 3), dtype=int64, chunksize=(2, 3), chunktype=numpy.ndarray&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;to_dask_array&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">to_dask_array</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;xarray.&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">from_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">getitem</span><span class="o">=</span><span class="n">getter_inline</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the input to a dask array.</span>

<span class="sd">    Subclasses of ``np.ndarray`` will be passed through as chunks unchanged.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like</span>
<span class="sd">        Input data, in any form that can be converted to a dask array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dask array</span>
<span class="sd">        Dask array interpretation of a.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; da.asanyarray(x)</span>
<span class="sd">    dask.array&lt;array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.ndarray&gt;</span>

<span class="sd">    &gt;&gt;&gt; y = [[1, 2, 3], [4, 5, 6]]</span>
<span class="sd">    &gt;&gt;&gt; da.asanyarray(y)</span>
<span class="sd">    dask.array&lt;array, shape=(2, 3), dtype=int64, chunksize=(2, 3), chunktype=numpy.ndarray&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;to_dask_array&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">to_dask_array</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;xarray.&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">stack</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">from_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">getitem</span><span class="o">=</span><span class="n">getter_inline</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_scalar_for_elemwise</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; is_scalar_for_elemwise(42)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_scalar_for_elemwise(&#39;foo&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_scalar_for_elemwise(True)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_scalar_for_elemwise(np.array(42))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_scalar_for_elemwise([1, 2, 3])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_scalar_for_elemwise(np.array([1, 2, 3]))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_scalar_for_elemwise(from_array(np.array(0), chunks=()))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_scalar_for_elemwise(np.dtype(&#39;i4&#39;))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the second half of shape_condition is essentially just to ensure that</span>
    <span class="c1"># dask series / frame are treated as scalars in elemwise.</span>
    <span class="n">maybe_shape</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">shape_condition</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maybe_shape</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
        <span class="n">is_dask_collection</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">maybe_shape</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">shape_condition</span>
        <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines output shape from broadcasting arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shapes : tuples</span>
<span class="sd">        The shapes of the arguments.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_shape : tuple</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input shapes cannot be successfully broadcast together.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sizes</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="n">shapes</span><span class="p">),</span> <span class="n">fillvalue</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">sizes</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;operands could not be broadcast together with &quot;</span>
                <span class="s2">&quot;shapes </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">shapes</span><span class="p">)))</span>
            <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">elemwise</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply elementwise function across arguments</span>

<span class="sd">    Respects broadcasting rules</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; elemwise(add, x, y)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; elemwise(sin, x)  # doctest: +SKIP</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    blockwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not take the following keyword arguments </span><span class="si">%s</span><span class="s2">&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">]))))</span>
        <span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_dask_collection</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
            <span class="c1"># Want to exclude Delayed shapes and dd.Scalar</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">]</span>
    <span class="n">out_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># Raises ValueError if dimensions mismatch</span>
    <span class="n">expr_inds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">out_ndim</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">need_enforce_dtype</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="s2">&quot;dtype&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We follow NumPy&#39;s rules for dtype promotion, which special cases</span>
        <span class="c1"># scalars and 0d ndarrays (which it considers equivalent) by using</span>
        <span class="c1"># their values to compute the result dtype:</span>
        <span class="c1"># https://github.com/numpy/numpy/issues/6240</span>
        <span class="c1"># We don&#39;t inspect the values of 0d dask arrays, because these could</span>
        <span class="c1"># hold potentially very expensive calculations. Instead, we treat</span>
        <span class="c1"># them just like other arrays, and if necessary cast the result of op</span>
        <span class="c1"># to match.</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar_for_elemwise</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span>
        <span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">apply_infer_dtype</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="p">{},</span> <span class="s2">&quot;elemwise&quot;</span><span class="p">,</span> <span class="n">suggest_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">need_enforce_dtype</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
            <span class="ow">not</span> <span class="n">is_scalar_for_elemwise</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span>
        <span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">funcname</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="n">blockwise_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">funcname</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">need_enforce_dtype</span><span class="p">:</span>
        <span class="n">blockwise_kwargs</span><span class="p">[</span><span class="s2">&quot;enforce_dtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">blockwise_kwargs</span><span class="p">[</span><span class="s2">&quot;enforce_dtype_function&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">_enforce_dtype</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">blockwise</span><span class="p">(</span>
        <span class="n">op</span><span class="p">,</span>
        <span class="n">expr_inds</span><span class="p">,</span>
        <span class="o">*</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar_for_elemwise</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span>
        <span class="p">),</span>
        <span class="o">**</span><span class="n">blockwise_kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">handle_out</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">handle_out</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handle out parameters</span>

<span class="sd">    If out is a dask.array then this overwrites the contents of that array with</span>
<span class="sd">    the result</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The out parameter is not fully supported&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Mismatched shapes between result and out parameter. &quot;</span>
                <span class="s2">&quot;out=</span><span class="si">%s</span><span class="s2">, result=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_chunks</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">chunks</span>
        <span class="n">out</span><span class="o">.</span><span class="n">dask</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">dask</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_meta</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_meta</span>
        <span class="n">out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;The out parameter is not fully supported.&quot;</span>
            <span class="s2">&quot; Received type </span><span class="si">%s</span><span class="s2">, expected Dask Array&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_enforce_dtype</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calls a function and converts its result to the given dtype.</span>

<span class="sd">    The parameters have deliberately been given unwieldy names to avoid</span>
<span class="sd">    clashes with keyword arguments consumed by blockwise</span>

<span class="sd">    A dtype of `object` is treated as a special case and not enforced,</span>
<span class="sd">    because it is used as a dummy value in some places when the result will</span>
<span class="sd">    not be a block in an Array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    enforce_dtype : dtype</span>
<span class="sd">        Result dtype</span>
<span class="sd">    enforce_dtype_function : callable</span>
<span class="sd">        The wrapped function, which will be passed the remaining arguments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;enforce_dtype&quot;</span><span class="p">)</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;enforce_dtype_function&quot;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Inferred dtype from function </span><span class="si">%r</span><span class="s2"> was </span><span class="si">%r</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;but got </span><span class="si">%r</span><span class="s2">, which can&#39;t be cast using &quot;</span>
                <span class="s2">&quot;casting=&#39;same_kind&#39;&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">funcname</span><span class="p">(</span><span class="n">function</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="c1"># scalar astype method doesn&#39;t take the keyword arguments, so</span>
            <span class="c1"># have to convert via 0-dimensional array and back.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># Missing copy kwarg</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Broadcast an array to a new shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The array to broadcast.</span>
<span class="sd">    shape : tuple</span>
<span class="sd">        The shape of the desired array.</span>
<span class="sd">    chunks : tuple, optional</span>
<span class="sd">        If provided, then the result will use these chunks instead of the same</span>
<span class="sd">        chunks as the source array. Setting chunks explicitly as part of</span>
<span class="sd">        broadcast_to is more efficient than rechunking afterwards. Chunks are</span>
<span class="sd">        only allowed to differ from the original shape along dimensions that</span>
<span class="sd">        are new on the result or have size 1 the input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    broadcast : dask array</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`numpy.broadcast_to`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">shape</span> <span class="ow">and</span> <span class="p">(</span><span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">chunks</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="n">ndim_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">ndim_new</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
        <span class="n">new</span> <span class="o">!=</span> <span class="n">old</span> <span class="k">for</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim_new</span><span class="p">:],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">old</span> <span class="o">!=</span> <span class="mi">1</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot broadcast shape </span><span class="si">%s</span><span class="s2"> to shape </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">s</span><span class="p">,)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">[:</span><span class="n">ndim_new</span><span class="p">])</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">bd</span> <span class="k">if</span> <span class="n">old</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="n">new</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">bd</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="n">ndim_new</span><span class="p">:])</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">normalize_chunks</span><span class="p">(</span>
            <span class="n">chunks</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">previous_chunks</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">old_bd</span><span class="p">,</span> <span class="n">new_bd</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">chunks</span><span class="p">[</span><span class="n">ndim_new</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="n">old_bd</span> <span class="o">!=</span> <span class="n">new_bd</span> <span class="ow">and</span> <span class="n">old_bd</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot broadcast chunks </span><span class="si">%s</span><span class="s2"> to chunks </span><span class="si">%s</span><span class="s2">: &quot;</span>
                    <span class="s2">&quot;new chunks must either be along a new &quot;</span>
                    <span class="s2">&quot;dimension or a dimension of size 1&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;broadcast_to-&quot;</span> <span class="o">+</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
    <span class="n">dsk</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">enumerated_chunks</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">bds</span><span class="p">)</span> <span class="k">for</span> <span class="n">bds</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">new_index</span><span class="p">,</span> <span class="n">chunk_shape</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">ec</span><span class="p">)</span> <span class="k">for</span> <span class="n">ec</span> <span class="ow">in</span> <span class="n">enumerated_chunks</span><span class="p">):</span>
        <span class="n">old_index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="mi">0</span> <span class="k">if</span> <span class="n">bd</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">bd</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">new_index</span><span class="p">[</span><span class="n">ndim_new</span><span class="p">:])</span>
        <span class="p">)</span>
        <span class="n">old_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">old_index</span>
        <span class="n">new_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">new_index</span>
        <span class="n">dsk</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">,</span> <span class="n">old_key</span><span class="p">,</span> <span class="n">quote</span><span class="p">(</span><span class="n">chunk_shape</span><span class="p">))</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dsk</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@derived_from</span><span class="p">(</span><span class="n">np</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">subok</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;subok&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

    <span class="n">to_array</span> <span class="o">=</span> <span class="n">asanyarray</span> <span class="k">if</span> <span class="n">subok</span> <span class="k">else</span> <span class="n">asarray</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">to_array</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unsupported keyword argument(s) provided&quot;</span><span class="p">)</span>

    <span class="c1"># Unify uneven chunking</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">uc_args</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">inds</span><span class="p">))</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">unify_chunks</span><span class="p">(</span><span class="o">*</span><span class="n">uc_args</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">broadcast_chunks</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">chunks</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">offset_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Offsets inputs by offset</span>

<span class="sd">    &gt;&gt;&gt; double = lambda x: x * 2</span>
<span class="sd">    &gt;&gt;&gt; f = offset_func(double, (10,))</span>
<span class="sd">    &gt;&gt;&gt; f(1)</span>
<span class="sd">    22</span>
<span class="sd">    &gt;&gt;&gt; f(300)</span>
<span class="sd">    620</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_offset</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">args2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args2</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">ignoring</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="n">_offset</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;offset_&quot;</span> <span class="o">+</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">return</span> <span class="n">_offset</span>


<span class="k">def</span> <span class="nf">chunks_from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Chunks tuple from nested list of arrays</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; chunks_from_arrays([x, x])</span>
<span class="sd">    ((2, 2),)</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; chunks_from_arrays([[x], [x]])</span>
<span class="sd">    ((1, 1), (2,))</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; chunks_from_arrays([[x, x]])</span>
<span class="sd">    ((1,), (2, 2))</span>

<span class="sd">    &gt;&gt;&gt; chunks_from_arrays([1, 1])</span>
<span class="sd">    ((1, 1),)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

    <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape</span><span class="p">(</span><span class="n">deepfirst</span><span class="p">(</span><span class="n">a</span><span class="p">))[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]))</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dim</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">deepfirst</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;First element in a nested list</span>

<span class="sd">    &gt;&gt;&gt; deepfirst([[[1, 2], [3, 4]], [5, 6], [7, 8]])</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">seq</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">deepfirst</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">shapelist</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get the shape of nested list &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shapelist</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>


<span class="k">def</span> <span class="nf">reshapelist</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reshape iterator to nested shape</span>

<span class="sd">    &gt;&gt;&gt; reshapelist((2, 3), range(6))</span>
<span class="sd">    [[0, 1, 2], [3, 4, 5]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">/</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">reshapelist</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">seq</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">transposelist</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">extradims</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Permute axes of nested list</span>

<span class="sd">    &gt;&gt;&gt; transposelist([[1,1,1],[1,1,1]], [2,1])</span>
<span class="sd">    [[[1, 1], [1, 1], [1, 1]]]</span>

<span class="sd">    &gt;&gt;&gt; transposelist([[1,1,1],[1,1,1]], [2,1], extradims=1)</span>
<span class="sd">    [[[[1], [1]], [[1], [1]], [[1], [1]]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndimlist</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of axes should equal depth of nested arrays&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">extradims</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`newdims` should be positive&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`axes` should be unique&quot;</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">shapelist</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">shape</span><span class="p">[</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">extradims</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">arrays</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">reshapelist</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_unknown_chunksizes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stack arrays along a new axis</span>

<span class="sd">    Given a sequence of dask arrays, form a new dask array by stacking them</span>
<span class="sd">    along a new dimension (axis=0 by default)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seq: list of dask.arrays</span>
<span class="sd">    axis: int</span>
<span class="sd">        Dimension along which to align all of the arrays</span>
<span class="sd">    allow_unknown_chunksizes: bool</span>
<span class="sd">        Allow unknown chunksizes, such as come from converting from dask</span>
<span class="sd">        dataframes.  Dask.array is unable to verify that chunks line up.  If</span>
<span class="sd">        data comes from differently aligned sources then this can cause</span>
<span class="sd">        unexpected results.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Create slices</span>

<span class="sd">    &gt;&gt;&gt; import dask.array as da</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; data = [from_array(np.ones((4, 4)), chunks=(2, 2))</span>
<span class="sd">    ...          for i in range(3)]</span>

<span class="sd">    &gt;&gt;&gt; x = da.stack(data, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (3, 4, 4)</span>

<span class="sd">    &gt;&gt;&gt; da.stack(data, axis=1).shape</span>
<span class="sd">    (4, 3, 4)</span>

<span class="sd">    &gt;&gt;&gt; da.stack(data, axis=-1).shape</span>
<span class="sd">    (4, 4, 3)</span>

<span class="sd">    Result is a new dask Array</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    concatenate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">wrap</span>

    <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need array(s) to stack&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_unknown_chunksizes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Stacked arrays must have the same shape. &quot;</span>
            <span class="s2">&quot;The first array had shape </span><span class="si">{0}</span><span class="s2">, while array &quot;</span>
            <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2"> has shape </span><span class="si">{2}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">meta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">meta_from_array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span>
        <span class="k">else</span> <span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">seq2</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">seq2</span><span class="p">:</span>
        <span class="n">seq2</span> <span class="o">=</span> <span class="n">seq</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">meta</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">meta</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">uc_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">))</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">seq2</span> <span class="o">=</span> <span class="n">unify_chunks</span><span class="p">(</span><span class="o">*</span><span class="n">uc_args</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chunks</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># same chunks</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n</span><span class="p">,)</span> <span class="o">+</span> <span class="n">seq2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">axis</span><span class="p">:]</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;stack-&quot;</span> <span class="o">+</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">))</span> <span class="k">for</span> <span class="n">bd</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]))</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]],)</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
    <span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span>
            <span class="n">getitem</span><span class="p">,</span>
            <span class="n">inp</span><span class="p">,</span>
            <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span>
            <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
            <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">axis</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span>
    <span class="p">]</span>

    <span class="n">layer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="n">seq2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">concatenate3</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursive np.concatenate</span>

<span class="sd">    Input should be a nested list of numpy arrays arranged in the order they</span>
<span class="sd">    should appear in the array itself.  Each array should have the same number</span>
<span class="sd">    of dimensions as the desired output and the nesting of the lists.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; concatenate3([[x, x, x], [x, x, x]])</span>
<span class="sd">    array([[1, 2, 1, 2, 1, 2],</span>
<span class="sd">           [1, 2, 1, 2, 1, 2]])</span>

<span class="sd">    &gt;&gt;&gt; concatenate3([[x, x], [x, x], [x, x]])</span>
<span class="sd">    array([[1, 2, 1, 2],</span>
<span class="sd">           [1, 2, 1, 2],</span>
<span class="sd">           [1, 2, 1, 2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">IS_NEP18_ACTIVE</span>

    <span class="c1"># We need this as __array_function__ may not exist on older NumPy versions.</span>
    <span class="c1"># And to reduce verbosity.</span>
    <span class="n">NDARRAY_ARRAY_FUNCTION</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="s2">&quot;__array_function__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">arrays</span> <span class="o">=</span> <span class="n">concrete</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">advanced</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">core</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)),</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;__array_priority__&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">IS_NEP18_ACTIVE</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">NDARRAY_ARRAY_FUNCTION</span>
        <span class="ow">is</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s2">&quot;__array_function__&quot;</span><span class="p">,</span> <span class="n">NDARRAY_ARRAY_FUNCTION</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span>
    <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">unpack_singleton</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_concatenate2</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">if</span> <span class="n">concatenate_lookup</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">advanced</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">unpack_singleton</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_concatenate2</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">ndimlist</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ndim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arrays</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">chunks_from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">chunks</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">(</span><span class="n">deepfirst</span><span class="p">(</span><span class="n">arrays</span><span class="p">)))</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">slices_from_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">),</span> <span class="n">core</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">arrays</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">concatenate_axes</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Recursively call np.concatenate along axes &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndimlist</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of axes should equal depth of nested arrays&quot;</span><span class="p">)</span>

    <span class="n">extradims</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">deepfirst</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">concatenate3</span><span class="p">(</span><span class="n">transposelist</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">extradims</span><span class="o">=</span><span class="n">extradims</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">to_hdf5</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store arrays in HDF5 file</span>

<span class="sd">    This saves several dask arrays into several datapaths in an HDF5 file.</span>
<span class="sd">    It creates the necessary datasets and handles clean file opening/closing.</span>

<span class="sd">    &gt;&gt;&gt; da.to_hdf5(&#39;myfile.hdf5&#39;, &#39;/x&#39;, x)  # doctest: +SKIP</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; da.to_hdf5(&#39;myfile.hdf5&#39;, {&#39;/x&#39;: x, &#39;/y&#39;: y})  # doctest: +SKIP</span>

<span class="sd">    Optionally provide arguments as though to ``h5py.File.create_dataset``</span>

<span class="sd">    &gt;&gt;&gt; da.to_hdf5(&#39;myfile.hdf5&#39;, &#39;/x&#39;, x, compression=&#39;lzf&#39;, shuffle=True)  # doctest: +SKIP</span>

<span class="sd">    This can also be used as a method on a single Array</span>

<span class="sd">    &gt;&gt;&gt; x.to_hdf5(&#39;myfile.hdf5&#39;, &#39;/x&#39;)  # doctest: +SKIP</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    da.store</span>
<span class="sd">    h5py.File.create_dataset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Array</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please provide {&#39;/data/path&#39;: array} dictionary&quot;</span><span class="p">)</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;chunks&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">h5py</span>

    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">dsets</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">f</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span>
                <span class="n">dp</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">chunks</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">])</span> <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">chunks</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">dp</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="n">store</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">dsets</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">interleave_none</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; interleave_none([0, None, 2, None], [1, 3])</span>
<span class="sd">    (0, 1, 2, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">keyname</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">okey</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; keyname(&#39;x&#39;, 3, [None, None, 0, 2])</span>
<span class="sd">    (&#39;x&#39;, 3, 0, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">okey</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_vindex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">indexes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Point wise indexing with broadcasting.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(56).reshape((7, 8))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0,  1,  2,  3,  4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11, 12, 13, 14, 15],</span>
<span class="sd">           [16, 17, 18, 19, 20, 21, 22, 23],</span>
<span class="sd">           [24, 25, 26, 27, 28, 29, 30, 31],</span>
<span class="sd">           [32, 33, 34, 35, 36, 37, 38, 39],</span>
<span class="sd">           [40, 41, 42, 43, 44, 45, 46, 47],</span>
<span class="sd">           [48, 49, 50, 51, 52, 53, 54, 55]])</span>

<span class="sd">    &gt;&gt;&gt; d = from_array(x, chunks=(3, 4))</span>
<span class="sd">    &gt;&gt;&gt; result = _vindex(d, [0, 1, 6, 0], [0, 1, 0, 7])</span>
<span class="sd">    &gt;&gt;&gt; result.compute()</span>
<span class="sd">    array([ 0,  9, 48,  7])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">replace_ellipsis</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>

    <span class="n">nonfancy_indexes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">reduced_indexes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="n">nonfancy_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">nonfancy_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="n">reduced_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nonfancy_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="n">reduced_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

    <span class="n">nonfancy_indexes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nonfancy_indexes</span><span class="p">)</span>
    <span class="n">reduced_indexes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">reduced_indexes</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">nonfancy_indexes</span><span class="p">]</span>

    <span class="n">array_indexes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">reduced_indexes</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;vindex does not support indexing with boolean arrays&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s2">&quot;vindex key has entries out of bounds for &quot;</span>
                    <span class="s2">&quot;indexing along axis </span><span class="si">%s</span><span class="s2"> of size </span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">ind</span> <span class="o">%=</span> <span class="n">size</span>
            <span class="n">array_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>

    <span class="k">if</span> <span class="n">array_indexes</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_vindex_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">array_indexes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_vindex_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dict_indexes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Point wise indexing with only NumPy Arrays.&quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">broadcast_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">dict_indexes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># note: error message exactly matches numpy</span>
        <span class="n">shapes_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dict_indexes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
            <span class="s2">&quot;shape mismatch: indexing arrays could not be &quot;</span>
            <span class="s2">&quot;broadcast together with shapes &quot;</span> <span class="o">+</span> <span class="n">shapes_str</span>
        <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">broadcast_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dict_indexes</span><span class="p">,</span> <span class="n">broadcast_indexes</span><span class="p">))</span>
    <span class="n">flat_indexes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">lookup</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lookup</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">flat_indexes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_indexes</span><span class="p">)))</span>

    <span class="n">flat_indexes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">flat_indexes</span>
    <span class="p">]</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">]</span>
    <span class="n">bounds2</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flat_indexes</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_get_axis</span><span class="p">(</span><span class="n">flat_indexes</span><span class="p">)</span>
    <span class="n">token</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">flat_indexes</span><span class="p">)</span>
    <span class="n">out_name</span> <span class="o">=</span> <span class="s2">&quot;vindex-merge-&quot;</span> <span class="o">+</span> <span class="n">token</span>

    <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flat_indexes</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])):</span>
        <span class="n">block_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">bisect</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bounds2</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>
        <span class="n">inblock_idx</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ind</span> <span class="o">-</span> <span class="n">bounds2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">block_idx</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">block_idx</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">inblock_idx</span><span class="p">)))</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flat_indexes</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">chunks</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),)</span> <span class="k">if</span> <span class="n">points</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">per_block</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
        <span class="n">per_block</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">per_block</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">other_blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">product</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flat_indexes</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">full_slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flat_indexes</span><span class="p">]</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;vindex-slice-&quot;</span> <span class="o">+</span> <span class="n">token</span>
        <span class="n">vindex_merge_name</span> <span class="o">=</span> <span class="s2">&quot;vindex-merge-&quot;</span> <span class="o">+</span> <span class="n">token</span>
        <span class="n">dsk</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">okey</span> <span class="ow">in</span> <span class="n">other_blocks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">per_block</span><span class="p">):</span>
                <span class="n">dsk</span><span class="p">[</span><span class="n">keyname</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">okey</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_vindex_transpose</span><span class="p">,</span>
                    <span class="p">(</span>
                        <span class="n">_vindex_slice</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">interleave_none</span><span class="p">(</span><span class="n">okey</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span>
                        <span class="n">interleave_none</span><span class="p">(</span>
                            <span class="n">full_slices</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">pluck</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">per_block</span><span class="p">[</span><span class="n">key</span><span class="p">])))</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                    <span class="n">axis</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">dsk</span><span class="p">[</span><span class="n">keyname</span><span class="p">(</span><span class="n">vindex_merge_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">okey</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_vindex_merge</span><span class="p">,</span>
                <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">pluck</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">per_block</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">per_block</span><span class="p">],</span>
                <span class="p">[</span><span class="n">keyname</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">okey</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">per_block</span><span class="p">))],</span>
            <span class="p">)</span>

        <span class="n">result_1d</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span>
            <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">out_name</span><span class="p">,</span> <span class="n">dsk</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">]),</span>
            <span class="n">out_name</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">,</span>
            <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result_1d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span> <span class="o">+</span> <span class="n">result_1d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># output has a zero dimension, just create a new zero-shape array with the</span>
    <span class="c1"># same dtype</span>
    <span class="kn">from</span> <span class="nn">.wrap</span> <span class="kn">import</span> <span class="n">empty</span>

    <span class="n">result_1d</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span>
        <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">out_name</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">result_1d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span> <span class="o">+</span> <span class="n">result_1d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>


<span class="k">def</span> <span class="nf">_get_axis</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get axis along which point-wise slicing results lie</span>

<span class="sd">    This is mostly a hack because I can&#39;t figure out NumPy&#39;s rule on this and</span>
<span class="sd">    can&#39;t be bothered to go reading.</span>

<span class="sd">    &gt;&gt;&gt; _get_axis([[1, 2], None, [1, 2], None])</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _get_axis([None, [1, 2], [1, 2], None])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; _get_axis([None, None, [1, 2], [1, 2]])</span>
<span class="sd">    2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexes</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">x2</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_vindex_slice</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Pull out point-wise slices from block &quot;&quot;&quot;</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">block</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">points</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_vindex_transpose</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Rotate block so that points are on the first dimension &quot;&quot;&quot;</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_vindex_merge</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; locations = [0], [2, 1]</span>
<span class="sd">    &gt;&gt;&gt; values = [np.array([[1, 2, 3]]),</span>
<span class="sd">    ...           np.array([[10, 20, 30], [40, 50, 60]])]</span>

<span class="sd">    &gt;&gt;&gt; _vindex_merge(locations, values)</span>
<span class="sd">    array([[ 1,  2,  3],</span>
<span class="sd">           [40, 50, 60],</span>
<span class="sd">           [10, 20, 30]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">locations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">locations</span><span class="p">))</span>
    <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">locations</span><span class="p">))</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">loc</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">x</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">to_npy_stack</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write dask array to a stack of .npy files</span>

<span class="sd">    This partitions the dask.array along one axis and stores each block along</span>
<span class="sd">    that axis as a single .npy file in the specified directory</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = da.ones((5, 10, 10), chunks=(2, 4, 4))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; da.to_npy_stack(&#39;data/&#39;, x, axis=0)  # doctest: +SKIP</span>

<span class="sd">    The ``.npy`` files store numpy arrays for ``x[0:2], x[2:4], and x[4:5]``</span>
<span class="sd">    respectively, as is specified by the chunk size along the zeroth axis::</span>

<span class="sd">        $ tree data/</span>
<span class="sd">        data/</span>
<span class="sd">        |-- 0.npy</span>
<span class="sd">        |-- 1.npy</span>
<span class="sd">        |-- 2.npy</span>
<span class="sd">        |-- info</span>

<span class="sd">    The ``info`` file stores the dtype, chunks, and axis information of the array.</span>
<span class="sd">    You can load these stacks with the ``da.from_npy_stack`` function.</span>

<span class="sd">    &gt;&gt;&gt; y = da.from_npy_stack(&#39;data/&#39;)  # doctest: +SKIP</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    from_npy_stack</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">c</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="k">else</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">),))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">rechunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>

    <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;chunks&quot;</span><span class="p">:</span> <span class="n">chunks</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="n">axis</span><span class="p">}</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;to-npy-stack-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>
    <span class="n">dsk</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">__dask_keys__</span><span class="p">()))</span>
    <span class="p">}</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">HighLevelGraph</span><span class="o">.</span><span class="n">from_collections</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dsk</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="n">xx</span><span class="p">])</span>
    <span class="n">compute_as_if_collection</span><span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">dsk</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">from_npy_stack</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load dask array from stack of npy files</span>

<span class="sd">    See ``da.to_npy_stack`` for docstring</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dirname: string</span>
<span class="sd">        Directory of .npy files</span>
<span class="sd">    mmap_mode: (None or &#39;r&#39;)</span>
<span class="sd">        Read data in memory map mode</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">),</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">]</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;from-npy-stack-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dirname</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]))</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">),</span> <span class="n">mmap_mode</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>
    <span class="p">]</span>
    <span class="n">dsk</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">dsk</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">meta_from_array</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Suhas Somnath, Gerd Duscher, and contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>